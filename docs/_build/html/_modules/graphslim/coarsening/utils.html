<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>graphslim.coarsening.utils &mdash; GraphSlim documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1"/>
    <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094"/>


    <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
    <![endif]-->

    <script src="../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../" id="documentation_options"
            src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../search.html"/>
</head>

<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
        <div class="wy-side-scroll">
            <div class="wy-side-nav-search">


                <a href="../../../index.html" class="icon icon-home">
                    GraphSlim
                </a>
                <div role="search">
                    <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
                        <input type="text" name="q" placeholder="Search docs" aria-label="Search docs"/>
                        <input type="hidden" name="check_keywords" value="yes"/>
                        <input type="hidden" name="area" value="default"/>
                    </form>
                </div>
            </div>
            <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
                <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal"
                                              href="../../../installation.html">Installation</a></li>
                </ul>
                <p class="caption" role="heading"><span class="caption-text">Quickstart</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start</a>
                    </li>
                </ul>
                <p class="caption" role="heading"><span class="caption-text">Dataset</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../source/graphslim.dataset.html">graphslim.dataset
                        package</a></li>
                </ul>
                <p class="caption" role="heading"><span class="caption-text">Models</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../source/graphslim.models.html">graphslim.models
                        package</a></li>
                </ul>
                <p class="caption" role="heading"><span class="caption-text">Method</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal"
                                              href="../../../source/graphslim.coarsening.html">graphslim.coarsening
                        package</a></li>
                    <li class="toctree-l1"><a class="reference internal"
                                              href="../../../source/graphslim.condensation.html">graphslim.condensation
                        package</a></li>
                    <li class="toctree-l1"><a class="reference internal"
                                              href="../../../source/graphslim.sparsification.html">graphslim.sparsification
                        package</a></li>
                </ul>
                <p class="caption" role="heading"><span class="caption-text">Evaluation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal"
                                              href="../../../source/graphslim.evaluation.html">graphslim.evaluation
                        package</a></li>
                </ul>

            </div>
        </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
        <nav class="wy-nav-top" aria-label="Mobile navigation menu">
            <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
            <a href="../../../index.html">GraphSlim</a>
        </nav>

        <div class="wy-nav-content">
            <div class="rst-content">
                <div role="navigation" aria-label="Page navigation">
                    <ul class="wy-breadcrumbs">
                        <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
                        <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
                        <li class="breadcrumb-item active">graphslim.coarsening.utils</li>
                        <li class="wy-breadcrumbs-aside">
                        </li>
                    </ul>
                    <hr/>
                </div>
                <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
                    <div itemprop="articleBody">

                        <h1>Source code for graphslim.coarsening.utils</h1>
                        <div class="highlight"><pre>
<span></span><span class="c1"># import matplotlib.pylab as plt</span>
<span class="kn">import</span> <span class="nn">numbers</span>

<span class="c1"># import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">pygsp</span> <span class="kn">import</span> <span class="n">filters</span><span
                                class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span
                                class="n">graphs</span>
<span class="kn">from</span> <span class="nn">pygsp.utils</span> <span class="kn">import</span> <span class="n">resistance_distance</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedList</span>

<span class="c1"># from graphslim.coarsening.maxWeightMatching import *</span>


<span class="sd">&quot;&quot;&quot;Weighted maximum matching in general graphs.</span>

<span class="sd">The algorithm is taken from &quot;Efficient Algorithms for Finding Maximum</span>
<span class="sd">Matching in Graphs&quot; by Zvi Galil, ACM Computing Surveys, 1986.</span>
<span class="sd">It is based on the &quot;blossom&quot; method for finding augmenting paths and</span>
<span class="sd">the &quot;primal-dual&quot; method for finding a matching of maximum weight, both</span>
<span class="sd">due to Jack Edmonds.</span>
<span class="sd">Some ideas came from &quot;Implementation of algorithms for maximum matching</span>
<span class="sd">on non-bipartite graphs&quot; by H.J. Gabow, Standford Ph.D. thesis, 1973.</span>

<span class="sd">A C program for maximum weight matching by Ed Rothberg was used extensively</span>
<span class="sd">to validate this new code.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">DEBUG</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">CHECK_DELTA</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">CHECK_OPTIMUM</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="maxWeightMatching"><a class="viewcode-back"
                                                      href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.maxWeightMatching">[docs]</a><span
        class="k">def</span> <span class="nf">maxWeightMatching</span><span class="p">(</span><span
        class="n">edges</span><span class="p">,</span> <span class="n">maxcardinality</span><span
        class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a maximum-weighted matching in the general undirected</span>
<span class="sd">    weighted graph given by &quot;edges&quot;.  If &quot;maxcardinality&quot; is true,</span>
<span class="sd">    only maximum-cardinality matchings are considered as solutions.</span>

<span class="sd">    Edges is a sequence of tuples (i, j, wt) describing an undirected</span>
<span class="sd">    edge between vertex i and vertex j with weight wt.  There is at most</span>
<span class="sd">    one edge between any two vertices; no vertex has an edge to itself.</span>
<span class="sd">    Vertices are identified by consecutive, non-negative integers.</span>

<span class="sd">    Return a list &quot;mate&quot;, such that mate[i] == j if vertex i is</span>
<span class="sd">    matched to vertex j, and mate[i] == -1 if vertex i is not matched.</span>

<span class="sd">    This function takes time O(n ** 3).&quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Vertices are numbered 0 .. (nvertex-1).</span>
    <span class="c1"># Non-trivial blossoms are numbered nvertex .. (2*nvertex-1)</span>
    <span class="c1">#</span>
    <span class="c1"># Edges are numbered 0 .. (nedge-1).</span>
    <span class="c1"># Edge endpoints are numbered 0 .. (2*nedge-1), such that endpoints</span>
    <span class="c1"># (2*k) and (2*k+1) both belong to edge k.</span>
    <span class="c1">#</span>
    <span class="c1"># Many terms used in the comments (sub-blossom, T-vertex) come from</span>
    <span class="c1"># the paper by Galil; read the paper before reading this code.</span>
    <span class="c1">#</span>

    <span class="c1"># # Python 2/3 compatibility.</span>
    <span class="c1"># if sys_version &lt; &#39;3&#39;:</span>
    <span class="c1">#     integer_types = (int, long)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     integer_types = (int,)</span>

    <span class="c1"># Deal swiftly with empty graphs.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Count vertices.</span>
    <span class="n">nedge</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">edges</span><span class="p">)</span>
    <span class="n">nvertex</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span
            class="n">edges</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">&gt;=</span> <span
            class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;=</span> <span
            class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span
            class="n">j</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
            <span class="n">nvertex</span> <span class="o">=</span> <span class="n">i</span> <span
            class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
            <span class="n">nvertex</span> <span class="o">=</span> <span class="n">j</span> <span
            class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Find the maximum edge weight.</span>
    <span class="n">maxweight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span
            class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span
            class="n">wt</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span
            class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">wt</span><span
            class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]))</span>

    <span class="c1"># If p is an edge endpoint,</span>
    <span class="c1"># endpoint[p] is the vertex to which endpoint p is attached.</span>
    <span class="c1"># Not modified by the algorithm.</span>
    <span class="n">endpoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">edges</span><span
            class="p">[</span><span class="n">p</span> <span class="o">//</span> <span class="mi">2</span><span
            class="p">][</span><span class="n">p</span> <span class="o">%</span> <span class="mi">2</span><span
            class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span
            class="n">nedge</span><span class="p">)]</span>

    <span class="c1"># If v is a vertex,</span>
    <span class="c1"># neighbend[v] is the list of remote endpoints of the edges attached to v.</span>
    <span class="c1"># Not modified by the algorithm.</span>
    <span class="n">neighbend</span> <span class="o">=</span> <span class="p">[[]</span> <span
            class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span
            class="p">)):</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">neighbend</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span
            class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span
            class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">)</span>
        <span class="n">neighbend</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span
            class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span
            class="o">*</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># If v is a vertex,</span>
    <span class="c1"># mate[v] is the remote endpoint of its matched edge, or -1 if it is single</span>
    <span class="c1"># (i.e. endpoint[mate[v]] is v&#39;s partner vertex).</span>
    <span class="c1"># Initially all vertices are single; updated during augmentation.</span>
    <span class="n">mate</span> <span class="o">=</span> <span class="n">nvertex</span> <span class="o">*</span> <span
            class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># If b is a top-level blossom,</span>
    <span class="c1"># label[b] is 0 if b is unlabeled (free);</span>
    <span class="c1">#             1 if b is an S-vertex/blossom;</span>
    <span class="c1">#             2 if b is a T-vertex/blossom.</span>
    <span class="c1"># The label of a vertex is found by looking at the label of its</span>
    <span class="c1"># top-level containing blossom.</span>
    <span class="c1"># If v is a vertex inside a T-blossom,</span>
    <span class="c1"># label[v] is 2 iff v is reachable from an S-vertex outside the blossom.</span>
    <span class="c1"># Labels are assigned during a stage and reset after each augmentation.</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span
            class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span
            class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If b is a labeled top-level blossom,</span>
    <span class="c1"># labelend[b] is the remote endpoint of the edge through which b obtained</span>
    <span class="c1"># its label, or -1 if b&#39;s base vertex is single.</span>
    <span class="c1"># If v is a vertex inside a T-blossom and label[v] == 2,</span>
    <span class="c1"># labelend[v] is the remote endpoint of the edge through which v is</span>
    <span class="c1"># reachable from outside the blossom.</span>
    <span class="n">labelend</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span
            class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span
            class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># If v is a vertex,</span>
    <span class="c1"># inblossom[v] is the top-level blossom to which v belongs.</span>
    <span class="c1"># If v is a top-level vertex, v is itself a blossom (a trivial blossom)</span>
    <span class="c1"># and inblossom[v] == v.</span>
    <span class="c1"># Initially all vertices are top-level trivial blossoms.</span>
    <span class="n">inblossom</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span
            class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">))</span>

    <span class="c1"># If b is a sub-blossom,</span>
    <span class="c1"># blossomparent[b] is its immediate parent (sub-)blossom.</span>
    <span class="c1"># If b is a top-level blossom, blossomparent[b] is -1.</span>
    <span class="n">blossomparent</span> <span class="o">=</span> <span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span
            class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># If b is a non-trivial (sub-)blossom,</span>
    <span class="c1"># blossomchilds[b] is an ordered list of its sub-blossoms, starting with</span>
    <span class="c1"># the base and going round the blossom.</span>
    <span class="n">blossomchilds</span> <span class="o">=</span> <span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span
            class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="c1"># If b is a (sub-)blossom,</span>
    <span class="c1"># blossombase[b] is its base VERTEX (i.e. recursive sub-blossom).</span>
    <span class="n">blossombase</span> <span class="o">=</span> <span class="nb">list</span><span
            class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span
            class="p">))</span> <span class="o">+</span> <span class="n">nvertex</span> <span class="o">*</span> <span
            class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># If b is a non-trivial (sub-)blossom,</span>
    <span class="c1"># blossomendps[b] is a list of endpoints on its connecting edges,</span>
    <span class="c1"># such that blossomendps[b][i] is the local endpoint of blossomchilds[b][i]</span>
    <span class="c1"># on the edge that connects it to blossomchilds[b][wrap(i+1)].</span>
    <span class="n">blossomendps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span
            class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span
            class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="c1"># If v is a free vertex (or an unreached vertex inside a T-blossom),</span>
    <span class="c1"># bestedge[v] is the edge to an S-vertex with least slack,</span>
    <span class="c1"># or -1 if there is no such edge.</span>
    <span class="c1"># If b is a (possibly trivial) top-level S-blossom,</span>
    <span class="c1"># bestedge[b] is the least-slack edge to a different S-blossom,</span>
    <span class="c1"># or -1 if there is no such edge.</span>
    <span class="c1"># This is used for efficient computation of delta2 and delta3.</span>
    <span class="n">bestedge</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span
            class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span class="o">*</span> <span
            class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># If b is a non-trivial top-level S-blossom,</span>
    <span class="c1"># blossombestedges[b] is a list of least-slack edges to neighbouring</span>
    <span class="c1"># S-blossoms, or None if no such list has been computed yet.</span>
    <span class="c1"># This is used for efficient computation of delta3.</span>
    <span class="n">blossombestedges</span> <span class="o">=</span> <span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span
            class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="c1"># List of currently unused blossom numbers.</span>
    <span class="n">unusedblossoms</span> <span class="o">=</span> <span class="nb">list</span><span
            class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span
            class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span
            class="p">))</span>

    <span class="c1"># If v is a vertex,</span>
    <span class="c1"># dualvar[v] = 2 * u(v) where u(v) is the v&#39;s variable in the dual</span>
    <span class="c1"># optimization problem (multiplication by two ensures integer values</span>
    <span class="c1"># throughout the algorithm if all edge weights are integers).</span>
    <span class="c1"># If b is a non-trivial blossom,</span>
    <span class="c1"># dualvar[b] = z(b) where z(b) is b&#39;s variable in the dual optimization</span>
    <span class="c1"># problem.</span>
    <span class="n">dualvar</span> <span class="o">=</span> <span class="n">nvertex</span> <span
            class="o">*</span> <span class="p">[</span><span class="n">maxweight</span><span class="p">]</span> <span
            class="o">+</span> <span class="n">nvertex</span> <span class="o">*</span> <span class="p">[</span><span
            class="mi">0</span><span class="p">]</span>

    <span class="c1"># If allowedge[k] is true, edge k has zero slack in the optimization</span>
    <span class="c1"># problem; if allowedge[k] is false, the edge&#39;s slack may or may not</span>
    <span class="c1"># be zero.</span>
    <span class="n">allowedge</span> <span class="o">=</span> <span class="n">nedge</span> <span
            class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

    <span class="c1"># Queue of newly discovered S-vertices.</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Return 2 * slack of edge k (does not work inside blossoms).</span>
    <span class="k">def</span> <span class="nf">slack</span><span class="p">(</span><span class="n">k</span><span
            class="p">):</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dualvar</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dualvar</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">wt</span>

    <span class="c1"># Generate the leaf vertices of a blossom.</span>
    <span class="k">def</span> <span class="nf">blossomLeaves</span><span class="p">(</span><span
            class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span
            class="n">nvertex</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span
            class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span
            class="n">nvertex</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">t</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span
            class="p">(</span><span class="n">t</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">v</span>

    <span class="c1"># Assign label t to the top-level blossom containing vertex w</span>
    <span class="c1"># and record the fact that w was reached through the edge with</span>
    <span class="c1"># remote endpoint p.</span>
    <span class="k">def</span> <span class="nf">assignLabel</span><span class="p">(</span><span class="n">w</span><span
            class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;assignLabel(</span><span class="si">%d</span><span
            class="s1">,</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span
            class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span
            class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">w</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">w</span><span
            class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span
            class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">==</span> <span class="mi">0</span>
        <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">labelend</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span
            class="p">:</span>
            <span class="c1"># b became an S-vertex/blossom; add it(s vertices) to the queue.</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span
            class="p">(</span><span class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span
            class="p">))</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span
            class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;PUSH &#39;</span> <span
            class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span
            class="p">(</span><span class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span
            class="p">))))</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">2</span><span
            class="p">:</span>
            <span class="c1"># b became a T-vertex/blossom; assign label S to its mate.</span>
            <span class="c1"># (If b is a non-trivial blossom, its base is the only vertex</span>
            <span class="c1"># with an external mate.)</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">blossombase</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">base</span><span
            class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">assignLabel</span><span class="p">(</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">mate</span><span class="p">[</span><span class="n">base</span><span
            class="p">]],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mate</span><span
            class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">^</span> <span
            class="mi">1</span><span class="p">)</span>

    <span class="c1"># Trace back from vertices v and w to discover either a new blossom</span>
    <span class="c1"># or an augmenting path. Return the base vertex of the new blossom or -1.</span>
    <span class="k">def</span> <span class="nf">scanBlossom</span><span class="p">(</span><span class="n">v</span><span
            class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;scanBlossom(</span><span class="si">%d</span><span
            class="s1">,</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span
            class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="c1"># Trace back from v and w, placing breadcrumbs as we go.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">!=</span> <span
            class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Look for a breadcrumb in v&#39;s blossom or put a new breadcrumb.</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">blossombase</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">5</span>
            <span class="c1"># Trace one step back.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span
            class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span
            class="p">]]</span>
            <span class="k">if</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">:</span>
                <span class="c1"># The base of blossom b is single; stop tracing this path.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span
            class="p">]]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c1"># b is a T-blossom; trace one more step back.</span>
                <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span
            class="p">]]</span>
            <span class="c1"># Swap v and w so that we alternate between both paths.</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">:</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span
            class="n">w</span><span class="p">,</span> <span class="n">v</span>
        <span class="c1"># Remove breadcrumbs.</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">path</span><span
            class="p">:</span>
            <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Return base vertex, if we found one.</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="c1"># Construct a new blossom with given base, containing edge k which</span>
    <span class="c1"># connects a pair of S vertices. Label the new blossom as S; set its dual</span>
    <span class="c1"># variable to zero; relabel its T-vertices to S and add them to the queue.</span>
    <span class="k">def</span> <span class="nf">addBlossom</span><span class="p">(</span><span
            class="n">base</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span
            class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">base</span><span class="p">]</span>
        <span class="n">bv</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">w</span><span class="p">]</span>
        <span class="c1"># Create blossom.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">unusedblossoms</span><span
            class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;addBlossom(</span><span class="si">%d</span><span
            class="s1">,</span><span class="si">%d</span><span class="s1">) (v=</span><span class="si">%d</span><span
            class="s1"> w=</span><span class="si">%d</span><span class="s1">) -&gt; </span><span
            class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span
            class="n">base</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span
            class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span><span
            class="p">))</span>
        <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">base</span>
        <span class="n">blossomparent</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossomparent</span><span class="p">[</span><span class="n">bb</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="c1"># Make list of sub-blossoms and their interconnecting edge endpoints.</span>
        <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span
            class="p">[]</span>
        <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">endps</span> <span class="o">=</span> <span
            class="p">[]</span>
        <span class="c1"># Trace back from v to base.</span>
        <span class="k">while</span> <span class="n">bv</span> <span class="o">!=</span> <span class="n">bb</span><span
            class="p">:</span>
            <span class="c1"># Add bv to the new blossom.</span>
            <span class="n">blossomparent</span><span class="p">[</span><span class="n">bv</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">bv</span><span class="p">)</span>
            <span class="n">endps</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span
            class="p">])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">label</span><span
            class="p">[</span><span class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span
            class="mi">2</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">label</span><span class="p">[</span><span
            class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span
            class="ow">and</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span
            class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span class="p">[</span><span
            class="n">blossombase</span><span class="p">[</span><span class="n">bv</span><span class="p">]]))</span>
            <span class="c1"># Trace one step back.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bv</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bv</span><span
            class="p">]]</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="c1"># Reverse lists, add endpoint that connects the pair of S vertices.</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
            class="n">bb</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">endps</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">endps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
        <span class="c1"># Trace back from w to base.</span>
        <span class="k">while</span> <span class="n">bw</span> <span class="o">!=</span> <span class="n">bb</span><span
            class="p">:</span>
            <span class="c1"># Add bw to the new blossom.</span>
            <span class="n">blossomparent</span><span class="p">[</span><span class="n">bw</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">bw</span><span class="p">)</span>
            <span class="n">endps</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span
            class="p">]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">label</span><span
            class="p">[</span><span class="n">bw</span><span class="p">]</span> <span class="o">==</span> <span
            class="mi">2</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">label</span><span class="p">[</span><span
            class="n">bw</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span
            class="ow">and</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span
            class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span class="p">[</span><span
            class="n">blossombase</span><span class="p">[</span><span class="n">bw</span><span class="p">]]))</span>
            <span class="c1"># Trace one step back.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bw</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bw</span><span
            class="p">]]</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">w</span><span class="p">]</span>
        <span class="c1"># Set label to S.</span>
        <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">bb</span><span
            class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">1</span>
        <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">bb</span><span
            class="p">]</span>
        <span class="c1"># Set dual variable to zero.</span>
        <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Relabel vertices.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span
            class="n">blossomLeaves</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># This T-vertex now turns into an S-vertex because it becomes</span>
                <span class="c1"># part of an S-blossom; add it to the queue.</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="c1"># Compute blossombestedges[b].</span>
        <span class="n">bestedgeto</span> <span class="o">=</span> <span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span
            class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bv</span> <span class="ow">in</span> <span class="n">path</span><span
            class="p">:</span>
            <span class="k">if</span> <span class="n">blossombestedges</span><span class="p">[</span><span
            class="n">bv</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span
            class="p">:</span>
                <span class="c1"># This subblossom does not have a list of least-slack edges;</span>
                <span class="c1"># get the information from the vertices.</span>
                <span class="n">nblists</span> <span class="o">=</span> <span class="p">[[</span><span
            class="n">p</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">for</span> <span
            class="n">p</span> <span class="ow">in</span> <span class="n">neighbend</span><span class="p">[</span><span
            class="n">v</span><span class="p">]]</span>
                           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span
            class="n">blossomLeaves</span><span class="p">(</span><span class="n">bv</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Walk this subblossom&#39;s least-slack edges.</span>
                <span class="n">nblists</span> <span class="o">=</span> <span class="p">[</span><span class="n">blossombestedges</span><span
            class="p">[</span><span class="n">bv</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">nblist</span> <span class="ow">in</span> <span
            class="n">nblists</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span
            class="n">nblist</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span
            class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">k</span><span
            class="p">]</span>
                    <span class="k">if</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span
            class="p">:</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span
            class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                    <span class="n">bj</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">bj</span> <span
            class="o">!=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">label</span><span
            class="p">[</span><span class="n">bj</span><span class="p">]</span> <span class="o">==</span> <span
            class="mi">1</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">bestedgeto</span><span class="p">[</span><span
            class="n">bj</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">or</span>
                             <span class="n">slack</span><span class="p">(</span><span class="n">k</span><span
            class="p">)</span> <span class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span
            class="n">bestedgeto</span><span class="p">[</span><span class="n">bj</span><span class="p">]))):</span>
                        <span class="n">bestedgeto</span><span class="p">[</span><span class="n">bj</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="c1"># Forget about least-slack edges of the subblossom.</span>
            <span class="n">blossombestedges</span><span class="p">[</span><span class="n">bv</span><span
            class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">bestedge</span><span class="p">[</span><span class="n">bv</span><span
            class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossombestedges</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span
            class="n">k</span> <span class="ow">in</span> <span class="n">bestedgeto</span> <span
            class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">]</span>
        <span class="c1"># Select bestedge[b].</span>
        <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span
            class="n">blossombestedges</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">or</span> <span class="n">slack</span><span class="p">(</span><span
            class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span
            class="p">]):</span>
                <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">k</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;blossomchilds[</span><span class="si">%d</span><span class="s1">]=&#39;</span> <span
            class="o">%</span> <span class="n">b</span> <span class="o">+</span> <span class="nb">repr</span><span
            class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">]))</span>

    <span class="c1"># Expand the given top-level blossom.</span>
    <span class="k">def</span> <span class="nf">expandBlossom</span><span class="p">(</span><span
            class="n">b</span><span class="p">,</span> <span class="n">endstage</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;expandBlossom(</span><span class="si">%d</span><span
            class="s1">,</span><span class="si">%d</span><span class="s1">) </span><span class="si">%s</span><span
            class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span
            class="p">,</span> <span class="n">endstage</span><span class="p">,</span> <span class="nb">repr</span><span
            class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">])))</span>
        <span class="c1"># Convert sub-blossoms into top-level blossoms.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span
            class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="n">blossomparent</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span
            class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span
            class="n">nvertex</span><span class="p">:</span>
                <span class="n">inblossom</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">s</span>
            <span class="k">elif</span> <span class="n">endstage</span> <span class="ow">and</span> <span class="n">dualvar</span><span
            class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span
            class="mi">0</span><span class="p">:</span>
                <span class="c1"># Recursively expand this sub-blossom.</span>
                <span class="n">expandBlossom</span><span class="p">(</span><span class="n">s</span><span
            class="p">,</span> <span class="n">endstage</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span
            class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="c1"># If we expand a T-blossom during a stage, its sub-blossoms must be</span>
        <span class="c1"># relabeled.</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span
            class="n">endstage</span><span class="p">)</span> <span class="ow">and</span> <span
            class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Start at the sub-blossom through which the expanding</span>
            <span class="c1"># blossom obtained its label, and relabel sub-blossoms untili</span>
            <span class="c1"># we reach the base.</span>
            <span class="c1"># Figure out through which sub-blossom the expanding blossom</span>
            <span class="c1"># obtained its label initially.</span>
            <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="n">entrychild</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">endpoint</span><span class="p">[</span><span
            class="n">labelend</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">^</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># Decide in which direction we will go round the blossom.</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">blossomchilds</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span
            class="p">(</span><span class="n">entrychild</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&amp;</span> <span
            class="mi">1</span><span class="p">:</span>
                <span class="c1"># Start index is odd; go forward and wrap.</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="nb">len</span><span
            class="p">(</span><span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">])</span>
                <span class="n">jstep</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Start index is even; go backward.</span>
                <span class="n">jstep</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># Move along the blossom until we get to the base.</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">labelend</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span
            class="mi">0</span><span class="p">:</span>
                <span class="c1"># Relabel the T-sub-blossom.</span>
                <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span
            class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span
            class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">endptrick</span><span
            class="p">]</span> <span class="o">^</span> <span class="n">endptrick</span> <span class="o">^</span> <span
            class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">assignLabel</span><span class="p">(</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span
            class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span
            class="p">)</span>
                <span class="c1"># Step to the next S-sub-blossom and note its forward endpoint.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">blossomendps</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span
            class="n">endptrick</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span
            class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">blossomendps</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span
            class="n">endptrick</span><span class="p">]</span> <span class="o">^</span> <span class="n">endptrick</span>
                <span class="c1"># Step to the next T-sub-blossom.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">p</span> <span
            class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span
            class="kc">True</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="c1"># Relabel the base T-sub-blossom WITHOUT stepping through to</span>
            <span class="c1"># its mate (so don&#39;t call assignLabel).</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="n">blossomchilds</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span
            class="p">]</span>
            <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span
            class="p">]]</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span
            class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">labelend</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span
            class="p">]]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bv</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">bestedge</span><span class="p">[</span><span class="n">bv</span><span
            class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># Continue along the blossom until we get back to entrychild.</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="k">while</span> <span class="n">blossomchilds</span><span class="p">[</span><span
            class="n">b</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span
            class="n">entrychild</span><span class="p">:</span>
                <span class="c1"># Examine the vertices of the sub-blossom to see whether</span>
                <span class="c1"># it is reachable from a neighbouring S-vertex outside the</span>
                <span class="c1"># expanding blossom.</span>
                <span class="n">bv</span> <span class="o">=</span> <span class="n">blossomchilds</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span
            class="p">]</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">bv</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span
            class="p">:</span>
                    <span class="c1"># This sub-blossom just got label S through one of its</span>
                    <span class="c1"># neighbours; leave it.</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span
            class="p">(</span><span class="n">bv</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span
            class="p">:</span>
                        <span class="k">break</span>
                <span class="c1"># If the sub-blossom contains a reachable vertex, assign</span>
                <span class="c1"># label T to the sub-blossom.</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span
            class="p">:</span>
                    <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="k">assert</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">bv</span>
                    <span class="n">label</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">0</span>
                    <span class="n">label</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">mate</span><span class="p">[</span><span class="n">blossombase</span><span
            class="p">[</span><span class="n">bv</span><span class="p">]]]]</span> <span class="o">=</span> <span
            class="mi">0</span>
                    <span class="n">assignLabel</span><span class="p">(</span><span class="n">v</span><span
            class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">labelend</span><span
            class="p">[</span><span class="n">v</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
        <span class="c1"># Recycle the blossom number.</span>
        <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">blossomendps</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">blossombestedges</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="kc">None</span>
        <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">unusedblossoms</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># Swap matched/unmatched edges over an alternating path through blossom b</span>
    <span class="c1"># between vertex v and the base vertex. Keep blossom bookkeeping consistent.</span>
    <span class="k">def</span> <span class="nf">augmentBlossom</span><span class="p">(</span><span
            class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;augmentBlossom(</span><span class="si">%d</span><span
            class="s1">,</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span
            class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="c1"># Bubble up through the blossom tree from vertex v to an immediate</span>
        <span class="c1"># sub-blossom of b.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">while</span> <span class="n">blossomparent</span><span class="p">[</span><span
            class="n">t</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span
            class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">blossomparent</span><span
            class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="c1"># Recursively deal with the first sub-blossom.</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
            <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">t</span><span
            class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># Decide in which direction we will go round the blossom.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span
            class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span
            class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span
            class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span
            class="p">:</span>
            <span class="c1"># Start index is odd; go forward and wrap.</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">jstep</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Start index is even; go backward.</span>
            <span class="n">jstep</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">endptrick</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Move along the blossom until we get to the base.</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span
            class="p">:</span>
            <span class="c1"># Step to the next sub-blossom and augment it recursively.</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">blossomchilds</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span
            class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">blossomendps</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span
            class="n">endptrick</span><span class="p">]</span> <span class="o">^</span> <span class="n">endptrick</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
                <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">t</span><span
            class="p">,</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span
            class="p">])</span>
            <span class="c1"># Step to the next sub-blossom and augment it recursively.</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">jstep</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">blossomchilds</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">j</span><span
            class="p">]</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
                <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">t</span><span
            class="p">,</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span
            class="o">^</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Match the edge connecting those sub-blossoms.</span>
            <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">=</span> <span
            class="n">p</span> <span class="o">^</span> <span class="mi">1</span>
            <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span
            class="p">]]</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span
            class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;PAIR </span><span
            class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> (k=</span><span
            class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span
            class="n">endpoint</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span
            class="n">endpoint</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span
            class="mi">1</span><span class="p">],</span> <span class="n">p</span> <span class="o">//</span> <span
            class="mi">2</span><span class="p">))</span>
        <span class="c1"># Rotate the list of sub-blossoms to put the new base at the front.</span>
        <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">blossomchilds</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">:]</span> <span
            class="o">+</span> <span class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span
            class="p">][:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">blossomendps</span><span class="p">[</span><span
            class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">:]</span> <span
            class="o">+</span> <span class="n">blossomendps</span><span class="p">[</span><span class="n">b</span><span
            class="p">][:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">blossombase</span><span class="p">[</span><span
            class="n">blossomchilds</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span
            class="mi">0</span><span class="p">]]</span>
        <span class="k">assert</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">==</span> <span class="n">v</span>

    <span class="c1"># Swap matched/unmatched edges over an alternating path between two</span>
    <span class="c1"># single vertices. The augmenting path runs through edge k, which</span>
    <span class="c1"># connects a pair of S vertices.</span>
    <span class="k">def</span> <span class="nf">augmentMatching</span><span class="p">(</span><span
            class="n">k</span><span class="p">):</span>
        <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span
            class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;augmentMatching(</span><span class="si">%d</span><span class="s1">) (v=</span><span
            class="si">%d</span><span class="s1"> w=</span><span class="si">%d</span><span
            class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span
            class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;PAIR </span><span class="si">%d</span><span class="s1"> </span><span
            class="si">%d</span><span class="s1"> (k=</span><span class="si">%d</span><span
            class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span
            class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span
            class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span
            class="n">v</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span
            class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span
            class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span> <span
            class="o">*</span> <span class="n">k</span><span class="p">)):</span>
            <span class="c1"># Match vertex s to remote endpoint p. Then trace back from s</span>
            <span class="c1"># until we find a single vertex, swapping matched and unmatched</span>
            <span class="c1"># edges as we go.</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span
            class="n">bs</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bs</span><span class="p">]</span> <span class="o">==</span> <span class="n">mate</span><span
            class="p">[</span><span class="n">blossombase</span><span class="p">[</span><span class="n">bs</span><span
            class="p">]]</span>
                <span class="c1"># Augment through the S-blossom from s to base.</span>
                <span class="k">if</span> <span class="n">bs</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
                    <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">bs</span><span
            class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="c1"># Update mate[s]</span>
                <span class="n">mate</span><span class="p">[</span><span class="n">s</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                <span class="c1"># Trace one step back.</span>
                <span class="k">if</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bs</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Reached single vertex; stop.</span>
                    <span class="k">break</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bs</span><span
            class="p">]]</span>
                <span class="n">bt</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span
            class="n">bt</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c1"># Trace one step back.</span>
                <span class="k">assert</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bt</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span
            class="p">]]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">labelend</span><span class="p">[</span><span class="n">bt</span><span
            class="p">]</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Augment through the T-blossom from j to base.</span>
                <span class="k">assert</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">bt</span><span
            class="p">]</span> <span class="o">==</span> <span class="n">t</span>
                <span class="k">if</span> <span class="n">bt</span> <span class="o">&gt;=</span> <span
            class="n">nvertex</span><span class="p">:</span>
                    <span class="n">augmentBlossom</span><span class="p">(</span><span class="n">bt</span><span
            class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="c1"># Update mate[j]</span>
                <span class="n">mate</span><span class="p">[</span><span class="n">j</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">labelend</span><span class="p">[</span><span
            class="n">bt</span><span class="p">]</span>
                <span class="c1"># Keep the opposite endpoint;</span>
                <span class="c1"># it will be assigned to mate[s] in the next step.</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">labelend</span><span
            class="p">[</span><span class="n">bt</span><span class="p">]</span> <span class="o">^</span> <span
            class="mi">1</span>
                <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span
            class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;PAIR </span><span
            class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> (k=</span><span
            class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span
            class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span> <span
            class="o">//</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Verify that the optimum solution has been reached.</span>
    <span class="k">def</span> <span class="nf">verifyOptimum</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">maxcardinality</span><span class="p">:</span>
            <span class="c1"># Vertices may have negative dual;</span>
            <span class="c1"># find a constant non-negative number to add to all vertex duals.</span>
            <span class="n">vdualoffset</span> <span class="o">=</span> <span class="nb">max</span><span
            class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span
            class="nb">min</span><span class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span
            class="n">nvertex</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vdualoffset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 0. all dual variables are non-negative</span>
        <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span
            class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span
            class="p">])</span> <span class="o">+</span> <span class="n">vdualoffset</span> <span class="o">&gt;=</span> <span
            class="mi">0</span>
        <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span
            class="n">dualvar</span><span class="p">[</span><span class="n">nvertex</span><span
            class="p">:])</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="c1"># 0. all edges have non-negative slack and</span>
        <span class="c1"># 1. all matched edges have zero slack;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">nedge</span><span class="p">):</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">dualvar</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dualvar</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">wt</span>
            <span class="n">iblossoms</span> <span class="o">=</span> <span class="p">[</span><span
            class="n">i</span><span class="p">]</span>
            <span class="n">jblossoms</span> <span class="o">=</span> <span class="p">[</span><span
            class="n">j</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">iblossoms</span><span
            class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span
            class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">iblossoms</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">blossomparent</span><span class="p">[</span><span
            class="n">iblossoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span
            class="p">]])</span>
            <span class="k">while</span> <span class="n">blossomparent</span><span class="p">[</span><span class="n">jblossoms</span><span
            class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span
            class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">jblossoms</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">blossomparent</span><span class="p">[</span><span
            class="n">jblossoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span
            class="p">]])</span>
            <span class="n">iblossoms</span><span class="o">.</span><span class="n">reverse</span><span
            class="p">()</span>
            <span class="n">jblossoms</span><span class="o">.</span><span class="n">reverse</span><span
            class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span
            class="n">bj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span
            class="p">(</span><span class="n">iblossoms</span><span class="p">,</span> <span
            class="n">jblossoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bi</span> <span class="o">!=</span> <span
            class="n">bj</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="mi">2</span> <span
            class="o">*</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">bi</span><span
            class="p">]</span>
            <span class="k">assert</span> <span class="n">s</span> <span class="o">&gt;=</span> <span
            class="mi">0</span>
            <span class="k">if</span> <span class="n">mate</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">==</span> <span
            class="n">k</span> <span class="ow">or</span> <span class="n">mate</span><span class="p">[</span><span
            class="n">j</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span
            class="o">==</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span
            class="o">==</span> <span class="n">k</span> <span class="ow">and</span> <span class="n">mate</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">//</span> <span
            class="mi">2</span> <span class="o">==</span> <span class="n">k</span>
                <span class="k">assert</span> <span class="n">s</span> <span class="o">==</span> <span
            class="mi">0</span>
        <span class="c1"># 2. all single vertices have zero dual value;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span
            class="ow">or</span> <span class="n">dualvar</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">+</span> <span class="n">vdualoffset</span> <span
            class="o">==</span> <span class="mi">0</span>
        <span class="c1"># 3. all blossoms with positive dual value are full.</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span
            class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">blossomendps</span><span
            class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">%</span> <span
            class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">blossomendps</span><span
            class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span
            class="mi">2</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">==</span> <span
            class="n">p</span> <span class="o">^</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span
            class="p">]]</span> <span class="o">==</span> <span class="n">p</span>
        <span class="c1"># Ok.</span>

    <span class="c1"># Check optimized delta2 against a trivial computation.</span>
    <span class="k">def</span> <span class="nf">checkDelta2</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bd</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">bk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span
            class="n">neighbend</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="o">//</span> <span
            class="mi">2</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">bk</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span
            class="o">&lt;</span> <span class="n">bd</span><span class="p">:</span>
                            <span class="n">bk</span> <span class="o">=</span> <span class="n">k</span>
                            <span class="n">bd</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span
            class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span
            class="ow">or</span> <span class="n">bk</span> <span class="o">!=</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span
            class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span
            class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span
            class="n">bd</span> <span class="o">!=</span> <span class="n">slack</span><span class="p">(</span><span
            class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])):</span>
                    <span class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;v=&#39;</span> <span
            class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span
            class="p">)</span> <span class="o">+</span> <span class="s1">&#39; bk=&#39;</span> <span class="o">+</span> <span
            class="nb">str</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span
            class="o">+</span> <span class="s1">&#39; bd=&#39;</span> <span class="o">+</span> <span
            class="nb">str</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span
            class="o">+</span> <span class="s1">&#39; bestedge=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span
            class="p">(</span>
                        <span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span
            class="o">+</span> <span class="s1">&#39; slack=&#39;</span> <span class="o">+</span> <span
            class="nb">str</span><span class="p">(</span><span class="n">slack</span><span class="p">(</span><span
            class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">])))</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">bk</span> <span
            class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span
            class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span
            class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span
            class="ow">or</span> <span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">and</span> <span class="n">bd</span> <span class="o">==</span> <span
            class="n">slack</span><span class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span
            class="n">v</span><span class="p">]))</span>

    <span class="c1"># Check optimized delta3 against a trivial computation.</span>
    <span class="k">def</span> <span class="nf">checkDelta3</span><span class="p">():</span>
        <span class="n">bk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tbk</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">tbd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span
            class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">blossomparent</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span
            class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">blossomLeaves</span><span
            class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">neighbend</span><span
            class="p">[</span><span class="n">v</span><span class="p">]:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span
            class="o">//</span> <span class="mi">2</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">w</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span> <span
            class="ow">and</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">k</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">bk</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span
            class="o">&lt;</span> <span class="n">bd</span><span class="p">:</span>
                                <span class="n">bk</span> <span class="o">=</span> <span class="n">k</span>
                                <span class="n">bd</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span
            class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">bestedge</span><span
            class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">assert</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span> <span
            class="ow">or</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span
            class="p">]</span> <span class="o">==</span> <span class="n">b</span>
                    <span class="k">assert</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span> <span
            class="ow">or</span> <span class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span
            class="p">]</span> <span class="o">!=</span> <span class="n">b</span>
                    <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">tbk</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span
            class="p">])</span> <span class="o">&lt;</span> <span class="n">tbd</span><span class="p">:</span>
                        <span class="n">tbk</span> <span class="o">=</span> <span class="n">bestedge</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span>
                        <span class="n">tbd</span> <span class="o">=</span> <span class="n">slack</span><span class="p">(</span><span
            class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span
            class="n">bd</span> <span class="o">!=</span> <span class="n">tbd</span><span class="p">:</span>
            <span class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;bk=</span><span
            class="si">%d</span><span class="s1"> tbk=</span><span class="si">%d</span><span class="s1"> bd=</span><span
            class="si">%s</span><span class="s1"> tbd=</span><span class="si">%s</span><span
            class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bk</span><span
            class="p">,</span> <span class="n">tbk</span><span class="p">,</span> <span class="nb">repr</span><span
            class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="nb">repr</span><span
            class="p">(</span><span class="n">tbd</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="n">bd</span> <span class="o">==</span> <span class="n">tbd</span>

    <span class="c1"># Main loop: continue until no further improvement is possible.</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">):</span>

        <span class="c1"># Each iteration of this loop is a &quot;stage&quot;.</span>
        <span class="c1"># A stage finds an augmenting path and uses that to improve</span>
        <span class="c1"># the matching.</span>
        <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span class="n">DEBUG</span><span
            class="p">(</span><span class="s1">&#39;STAGE </span><span class="si">%d</span><span class="s1">&#39;</span> <span
            class="o">%</span> <span class="n">t</span><span class="p">)</span>

        <span class="c1"># Remove labels from top-level blossoms/vertices.</span>
        <span class="n">label</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span
            class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Forget all about least-slack edges.</span>
        <span class="n">bestedge</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">)</span> <span
            class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">blossombestedges</span><span class="p">[</span><span class="n">nvertex</span><span
            class="p">:]</span> <span class="o">=</span> <span class="n">nvertex</span> <span class="o">*</span> <span
            class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Loss of labeling means that we can not be sure that currently</span>
        <span class="c1"># allowable edges remain allowable througout this stage.</span>
        <span class="n">allowedge</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nedge</span> <span
            class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

        <span class="c1"># Make queue empty.</span>
        <span class="n">queue</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Label single blossoms/vertices with S and put them in the queue.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span
            class="ow">and</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">assignLabel</span><span class="p">(</span><span class="n">v</span><span
            class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">)</span>

        <span class="c1"># Loop until we succeed in augmenting the matching.</span>
        <span class="n">augmented</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># Each iteration of this loop is a &quot;substage&quot;.</span>
            <span class="c1"># A substage tries to find an augmenting path;</span>
            <span class="c1"># if found, the path is used to improve the matching and</span>
            <span class="c1"># the stage ends. If there is no augmenting path, the</span>
            <span class="c1"># primal-dual method is used to pump some slack out of</span>
            <span class="c1"># the dual variables.</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span
            class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;SUBSTAGE&#39;</span><span
            class="p">)</span>

            <span class="c1"># Continue labeling until all vertices which are reachable</span>
            <span class="c1"># through an alternating path have got a label.</span>
            <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span
            class="ow">not</span> <span class="n">augmented</span><span class="p">:</span>

                <span class="c1"># Take an S vertex from the queue.</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span
            class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span
            class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;POP v=</span><span
            class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">v</span><span
            class="p">)</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span>

                <span class="c1"># Scan its neighbours:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span
            class="n">neighbend</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">p</span> <span class="o">//</span> <span
            class="mi">2</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">endpoint</span><span
            class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="c1"># w is a neighbour to v</span>
                    <span class="k">if</span> <span class="n">inblossom</span><span class="p">[</span><span
            class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="c1"># this edge is internal to a blossom; ignore it</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">allowedge</span><span
            class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">kslack</span> <span class="o">=</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">kslack</span> <span class="o">&lt;=</span> <span
            class="mi">0</span><span class="p">:</span>
                            <span class="c1"># edge k has zero slack =&gt; it is allowable</span>
                            <span class="n">allowedge</span><span class="p">[</span><span class="n">k</span><span
            class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">allowedge</span><span class="p">[</span><span
            class="n">k</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">0</span><span class="p">:</span>
                            <span class="c1"># (C1) w is a free vertex;</span>
                            <span class="c1"># label w with T and label its mate with S (R12).</span>
                            <span class="n">assignLabel</span><span class="p">(</span><span class="n">w</span><span
            class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span> <span
            class="o">^</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span><span class="p">:</span>
                            <span class="c1"># (C2) w is an S-vertex (not in the same blossom);</span>
                            <span class="c1"># follow back-links to discover either an</span>
                            <span class="c1"># augmenting path or a new blossom.</span>
                            <span class="n">base</span> <span class="o">=</span> <span class="n">scanBlossom</span><span
            class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span
            class="p">)</span>
                            <span class="k">if</span> <span class="n">base</span> <span class="o">&gt;=</span> <span
            class="mi">0</span><span class="p">:</span>
                                <span class="c1"># Found a new blossom; add it to the blossom</span>
                                <span class="c1"># bookkeeping and turn it into an S-blossom.</span>
                                <span class="n">addBlossom</span><span class="p">(</span><span
            class="n">base</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Found an augmenting path; augment the</span>
                                <span class="c1"># matching and end this stage.</span>
                                <span class="n">augmentMatching</span><span class="p">(</span><span
            class="n">k</span><span class="p">)</span>
                                <span class="n">augmented</span> <span class="o">=</span> <span class="mi">1</span>
                                <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">w</span><span
            class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># w is inside a T-blossom, but w itself has not</span>
                            <span class="c1"># yet been reached from outside the blossom;</span>
                            <span class="c1"># mark it as reached (we need this to relabel</span>
                            <span class="c1"># during T-blossom expansion).</span>
                            <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">2</span>
                            <span class="n">label</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">2</span>
                            <span class="n">labelend</span><span class="p">[</span><span class="n">w</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">^</span> <span
            class="mi">1</span>
                    <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span><span class="p">:</span>
                        <span class="c1"># keep track of the least-slack non-allowable edge to</span>
                        <span class="c1"># a different S-blossom.</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">inblossom</span><span
            class="p">[</span><span class="n">v</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">or</span> <span class="n">kslack</span> <span
            class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span
            class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span class="p">]):</span>
                            <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span
            class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span
            class="p">:</span>
                        <span class="c1"># w is a free vertex (or an unreached vertex inside</span>
                        <span class="c1"># a T-blossom) but we can not reach it yet;</span>
                        <span class="c1"># keep track of the least-slack edge that reaches w.</span>
                        <span class="k">if</span> <span class="n">bestedge</span><span class="p">[</span><span
            class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">or</span> <span class="n">kslack</span> <span
            class="o">&lt;</span> <span class="n">slack</span><span class="p">(</span><span
            class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span class="p">]):</span>
                            <span class="n">bestedge</span><span class="p">[</span><span class="n">w</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">k</span>

            <span class="k">if</span> <span class="n">augmented</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># There is no augmenting path under these constraints;</span>
            <span class="c1"># compute delta and reduce slack in the optimization problem.</span>
            <span class="c1"># (Note that our vertex dual variables, edge slacks and delta&#39;s</span>
            <span class="c1"># are pre-multiplied by two.)</span>
            <span class="n">deltatype</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">deltaedge</span> <span
            class="o">=</span> <span class="n">deltablossom</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Verify data structures for delta2/delta3 computation.</span>
            <span class="k">if</span> <span class="n">CHECK_DELTA</span><span class="p">:</span>
                <span class="n">checkDelta2</span><span class="p">()</span>
                <span class="n">checkDelta3</span><span class="p">()</span>

            <span class="c1"># Compute delta1: the minumum value of any vertex dual.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">maxcardinality</span><span
            class="p">:</span>
                <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">min</span><span
            class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span
            class="p">])</span>

            <span class="c1"># Compute delta2: the minimum slack on any edge between</span>
            <span class="c1"># an S-vertex and a free vertex.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span
            class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span
            class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">v</span><span
            class="p">])</span>
                    <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span
            class="o">&lt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">deltaedge</span> <span class="o">=</span> <span class="n">bestedge</span><span
            class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="c1"># Compute delta3: half the minimum slack on any edge between</span>
            <span class="c1"># a pair of S-blossoms.</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span
            class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">blossomparent</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">label</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span
            class="mi">1</span> <span class="ow">and</span>
                        <span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span
            class="p">):</span>
                    <span class="n">kslack</span> <span class="o">=</span> <span class="n">slack</span><span
            class="p">(</span><span class="n">bestedge</span><span class="p">[</span><span class="n">b</span><span
            class="p">])</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kslack</span><span
            class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span
            class="n">Integral</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="p">(</span><span class="n">kslack</span> <span
            class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span
            class="mi">0</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">kslack</span> <span class="o">//</span> <span
            class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">kslack</span> <span class="o">/</span> <span
            class="mi">2</span>
                    <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">d</span> <span
            class="o">&lt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="n">d</span>
                        <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">3</span>
                        <span class="n">deltaedge</span> <span class="o">=</span> <span class="n">bestedge</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span>

            <span class="c1"># Compute delta4: minimum z variable of any T-blossom.</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span
            class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">blossombase</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span
            class="mi">0</span> <span class="ow">and</span> <span class="n">blossomparent</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span> <span class="ow">and</span>
                        <span class="n">label</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">deltatype</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">dualvar</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;</span> <span
            class="n">delta</span><span class="p">)):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">dualvar</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span>
                    <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">4</span>
                    <span class="n">deltablossom</span> <span class="o">=</span> <span class="n">b</span>

            <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># No further improvement possible; max-cardinality optimum</span>
                <span class="c1"># reached. Do a final delta update to make the optimum</span>
                <span class="c1"># verifyable.</span>
                <span class="k">assert</span> <span class="n">maxcardinality</span>
                <span class="n">deltatype</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span><span
            class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span
            class="p">(</span><span class="n">dualvar</span><span class="p">[:</span><span class="n">nvertex</span><span
            class="p">]))</span>

            <span class="c1"># Update dual variables according to delta.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># S-vertex: 2*u = 2*u - 2*delta</span>
                    <span class="n">dualvar</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">-=</span> <span class="n">delta</span>
                <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">2</span><span class="p">:</span>
                    <span class="c1"># T-vertex: 2*u = 2*u + 2*delta</span>
                    <span class="n">dualvar</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span class="mi">2</span> <span
            class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">blossombase</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span
            class="ow">and</span> <span class="n">blossomparent</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span
            class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span
            class="p">:</span>
                        <span class="c1"># top-level S-blossom: z = z + 2*delta</span>
                        <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                    <span class="k">elif</span> <span class="n">label</span><span class="p">[</span><span
            class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span
            class="p">:</span>
                        <span class="c1"># top-level T-blossom: z = z - 2*delta</span>
                        <span class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span
            class="p">]</span> <span class="o">-=</span> <span class="n">delta</span>

            <span class="c1"># Take action at the point where minimum delta occurred.</span>
            <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span> <span
            class="n">DEBUG</span><span class="p">(</span><span class="s1">&#39;delta</span><span
            class="si">%d</span><span class="s1">=</span><span class="si">%f</span><span class="s1">&#39;</span> <span
            class="o">%</span> <span class="p">(</span><span class="n">deltatype</span><span class="p">,</span> <span
            class="n">delta</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="mi">1</span><span class="p">:</span>
                <span class="c1"># No further improvement possible; optimum reached.</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="mi">2</span><span class="p">:</span>
                <span class="c1"># Use the least-slack edge to continue the search.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span> <span
            class="o">=</span> <span class="kc">True</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span
            class="n">inblossom</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span
            class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span
            class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="mi">3</span><span class="p">:</span>
                <span class="c1"># Use the least-slack edge to continue the search.</span>
                <span class="n">allowedge</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span> <span
            class="o">=</span> <span class="kc">True</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[</span><span class="n">deltaedge</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">label</span><span class="p">[</span><span class="n">inblossom</span><span
            class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span
            class="mi">1</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">deltatype</span> <span class="o">==</span> <span
            class="mi">4</span><span class="p">:</span>
                <span class="c1"># Expand the least-z blossom.</span>
                <span class="n">expandBlossom</span><span class="p">(</span><span class="n">deltablossom</span><span
            class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="c1"># End of a this substage.</span>

        <span class="c1"># Stop when no more augmenting path can be found.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">augmented</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># End of a stage; expand all S-blossoms which have dualvar = 0.</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">nvertex</span><span class="p">,</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">nvertex</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">blossomparent</span><span
            class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span
            class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span
            class="n">blossombase</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span>
                    <span class="n">label</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span
            class="n">dualvar</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span
            class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">expandBlossom</span><span class="p">(</span><span class="n">b</span><span
            class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Verify that we reached the optimum solution.</span>
    <span class="k">if</span> <span class="n">CHECK_OPTIMUM</span><span class="p">:</span>
        <span class="n">verifyOptimum</span><span class="p">()</span>

    <span class="c1"># Transform mate[] such that mate[v] is the vertex to which v is paired.</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">mate</span><span
            class="p">[</span><span class="n">v</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">nvertex</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">mate</span><span class="p">[</span><span class="n">v</span><span
            class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span
            class="ow">or</span> <span class="n">mate</span><span class="p">[</span><span class="n">mate</span><span
            class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">==</span> <span
            class="n">v</span>

    <span class="k">return</span> <span class="n">mate</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># General coarsening utility functions</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="coarsen_vector"><a class="viewcode-back"
                                                   href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.coarsen_vector">[docs]</a><span
        class="k">def</span> <span class="nf">coarsen_vector</span><span class="p">(</span><span class="n">x</span><span
        class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coarsen a vector by applying the square of a matrix and then performing a dot product.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input vector to be coarsened.</span>
<span class="sd">    C : scipy.sparse.csr_matrix or array_like</span>
<span class="sd">        Matrix used to coarsen the vector. The matrix is squared before the dot product is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The resulting vector after coarsening.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.sparse import csr_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; C = csr_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])</span>
<span class="sd">    &gt;&gt;&gt; coarsen_vector(x, C)</span>
<span class="sd">    array([ 1,  8, 27])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span
            class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span
            class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="lift_vector"><a class="viewcode-back"
                                                href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.lift_vector">[docs]</a><span
        class="k">def</span> <span class="nf">lift_vector</span><span class="p">(</span><span
        class="n">input_vector</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lift a vector by applying a transformation involving a matrix and its pseudoinverse.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_vector : array_like</span>
<span class="sd">        Input vector to be lifted.</span>
<span class="sd">    C : scipy.sparse.csr_matrix or array_like</span>
<span class="sd">        Matrix used in the lifting process. A pseudoinverse transformation is applied to this matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The resulting vector after lifting.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function creates a diagonal matrix `D` based on the inverse of the sum of `C` along the columns.</span>
<span class="sd">    It then computes `Pinv`, the transpose of the product of `C` and `D`. The final lifted vector is obtained</span>
<span class="sd">    by performing a dot product of `Pinv` and the input vector.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.sparse import csr_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; input_vector = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; C = csr_matrix([[1, 2, 0], [0, 1, 3], [4, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; lift_vector(input_vector, C)</span>
<span class="sd">    array([0.57142857, 0.14285714, 0.85714286])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span
            class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span> <span
            class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span
            class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axis</span><span
            class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span
            class="p">])</span>
    <span class="n">Pinv</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span
            class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">))</span><span
            class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">Pinv</span><span class="o">.</span><span class="n">dot</span><span
            class="p">(</span><span class="n">input_vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="coarsen_matrix"><a class="viewcode-back"
                                                   href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.coarsen_matrix">[docs]</a><span
        class="k">def</span> <span class="nf">coarsen_matrix</span><span class="p">(</span><span class="n">W</span><span
        class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coarsen the input adjacency matrix W using the coarsening matrix C.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    W : scipy.sparse.csr_matrix or array_like</span>
<span class="sd">        The original adjacency matrix to be coarsened.</span>
<span class="sd">    C : scipy.sparse.csr_matrix or array_like</span>
<span class="sd">        The coarsening matrix used to reduce the size of the original matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coarsened_W : scipy.sparse.csr_matrix or numpy.ndarray</span>
<span class="sd">        The coarsened adjacency matrix obtained after applying the coarsening process.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.sparse import csr_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; W = csr_matrix([[0, 1, 0], [1, 0, 1], [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; C = csr_matrix([[1, 0], [0, 1], [1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; coarsen_matrix(W, C)</span>
<span class="sd">    matrix([[0.5, 0.5],</span>
<span class="sd">            [0.5, 0.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a diagonal matrix D where each element is the inverse of the sum of the corresponding column in C</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span
            class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span> <span
            class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span
            class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axis</span><span
            class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span
            class="p">])</span>

    <span class="c1"># Compute the pseudo-inverse of C by multiplying C with D and then transposing</span>
    <span class="n">Pinv</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span
            class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="p">))</span><span
            class="o">.</span><span class="n">T</span>

    <span class="c1"># Coarsen the matrix W by first multiplying W with Pinv from the right,</span>
    <span class="c1"># and then multiplying the result with the transpose of Pinv from the left</span>
    <span class="n">coarsened_W</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pinv</span><span
            class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span
            class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span
            class="n">Pinv</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">coarsened_W</span></div>



<div class="viewcode-block" id="lift_matrix"><a class="viewcode-back"
                                                href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.lift_matrix">[docs]</a><span
        class="k">def</span> <span class="nf">lift_matrix</span><span class="p">(</span><span class="n">W</span><span
        class="p">,</span> <span class="n">C</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lift the input adjacency matrix W using the lifting matrix C.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    W : scipy.sparse.csr_matrix or array_like</span>
<span class="sd">        The original adjacency matrix to be lifted.</span>
<span class="sd">    C : scipy.sparse.csr_matrix or array_like</span>
<span class="sd">        The lifting matrix used to expand the size of the original matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lifted_W : scipy.sparse.csr_matrix or numpy.ndarray</span>
<span class="sd">        The lifted adjacency matrix obtained after applying the lifting process.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.sparse import csr_matrix</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; W = csr_matrix([[0, 1], [1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; C = csr_matrix([[1, 0], [0, 1], [1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; lift_matrix(W, C)</span>
<span class="sd">    matrix([[0., 1., 0.],</span>
<span class="sd">            [1., 0., 1.],</span>
<span class="sd">            [0., 1., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the element-wise square of the matrix C to obtain P</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">power</span><span
            class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Lift the matrix W by first multiplying W with P from the right,</span>
    <span class="c1"># and then multiplying the result with the transpose of P from the left</span>
    <span class="n">lifted_W</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span
            class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span
            class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span
            class="n">P</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">lifted_W</span></div>


<div class="viewcode-block" id="get_coarsening_matrix"><a class="viewcode-back"
                                                          href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.get_coarsening_matrix">[docs]</a><span
        class="k">def</span> <span class="nf">get_coarsening_matrix</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">partitioning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the coarsening matrix C for a given graph G based on the specified partitioning.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : Graph</span>
<span class="sd">        The graph to be coarsened. The graph should have an attribute `N` representing the number of nodes.</span>
<span class="sd">    partitioning : list of lists</span>
<span class="sd">        A list of subgraphs, where each subgraph is represented as a list of node indices to be contracted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C : scipy.sparse.csc_matrix</span>
<span class="sd">        The coarsening matrix.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from gsp.graphs import sensor</span>
<span class="sd">    &gt;&gt;&gt; G = sensor(20)</span>
<span class="sd">    &gt;&gt;&gt; partitioning = [[0, 1], [2, 3, 4], [5, 6, 7, 8]]</span>
<span class="sd">    &gt;&gt;&gt; C = get_coarsening_matrix(G, partitioning)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize the coarsening matrix C as an identity matrix in sparse format</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span
            class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">N</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span
            class="s2">&quot;lil&quot;</span><span class="p">)</span>

    <span class="c1"># List to keep track of rows to be deleted</span>
    <span class="n">rows_to_delete</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">subgraph</span> <span class="ow">in</span> <span
            class="n">partitioning</span><span class="p">:</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">subgraph</span><span class="p">)</span>

        <span class="c1"># Update the first row of the subgraph with normalized values</span>
        <span class="n">C</span><span class="p">[</span><span class="n">subgraph</span><span class="p">[</span><span
            class="mi">0</span><span class="p">],</span> <span class="n">subgraph</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span
            class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nc</span><span
            class="p">)</span>

        <span class="c1"># Collect rows to delete, excluding the first row of the subgraph</span>
        <span class="n">rows_to_delete</span><span class="o">.</span><span class="n">extend</span><span
            class="p">(</span><span class="n">subgraph</span><span class="p">[</span><span class="mi">1</span><span
            class="p">:])</span>

    <span class="c1"># Delete the rows corresponding to the contracted nodes</span>
    <span class="n">C</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span
            class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span
            class="n">C</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span
            class="n">rows_to_delete</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span
            class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span
            class="n">C</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span
            class="n">rows_to_delete</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span
            class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">N</span> <span
            class="o">-</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">rows_to_delete</span><span class="p">),</span> <span class="n">G</span><span
            class="o">.</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Convert the coarsening matrix to Compressed Sparse Column format</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span
            class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">C</span><span
            class="p">)</span>

    <span class="c1"># Optional: check that this is a projection matrix</span>
    <span class="c1"># assert sp.sparse.linalg.norm(((C.T).dot(C))**2 - ((C.T).dot(C)), ord=&#39;fro&#39;) &lt; 1e-5</span>

    <span class="k">return</span> <span class="n">C</span></div>


<div class="viewcode-block" id="coarsening_quality"><a class="viewcode-back"
                                                       href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.coarsening_quality">[docs]</a><span
        class="k">def</span> <span class="nf">coarsening_quality</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span
        class="n">kmax</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">Uk</span><span
        class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lk</span><span class="o">=</span><span
        class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Measures the quality of a coarsening.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graphs.Graph</span>
<span class="sd">        The original graph to be coarsened.</span>
<span class="sd">    C : np.array</span>
<span class="sd">        The coarsening matrix of shape (n, N).</span>
<span class="sd">    kmax : int, optional</span>
<span class="sd">        The maximum number of eigenvalues/eigenvectors to consider. Default is 30.</span>
<span class="sd">    Uk : np.array, optional</span>
<span class="sd">        Precomputed eigenvectors of the graph Laplacian. Default is None.</span>
<span class="sd">    lk : np.array, optional</span>
<span class="sd">        Precomputed eigenvalues of the graph Laplacian. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metrics : dict</span>
<span class="sd">        A dictionary containing various metrics for coarsening quality:</span>

<span class="sd">        * &#39;error_eigenvalue&#39; : np.array</span>
<span class="sd">            Relative error of eigenvalues.</span>
<span class="sd">        * &#39;error_subspace&#39; : np.array</span>
<span class="sd">            Subspace error.</span>
<span class="sd">        * &#39;error_sintheta&#39; : np.array</span>
<span class="sd">            Sine of the principal angles between subspaces.</span>
<span class="sd">        * &#39;angle_matrix&#39; : np.array</span>
<span class="sd">            Matrix of angles between eigenvectors.</span>
<span class="sd">        * &#39;r&#39; : int</span>
<span class="sd">            Reduction ratio.</span>
<span class="sd">        * &#39;m&#39; : int</span>
<span class="sd">            Number of edges in the coarsened graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pygsp import graphs</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; G = graphs.Sensor(20)</span>
<span class="sd">    &gt;&gt;&gt; C = np.random.rand(10, 20)</span>
<span class="sd">    &gt;&gt;&gt; metrics = coarsening_quality(G, C)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">N</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span
            class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Use provided eigenvectors/eigenvalues or compute them if not provided</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Uk</span> <span class="ow">is</span> <span
            class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span
            class="p">(</span><span class="n">lk</span> <span class="ow">is</span> <span class="ow">not</span> <span
            class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span
            class="nb">len</span><span class="p">(</span><span class="n">lk</span><span class="p">)</span> <span
            class="o">&gt;=</span> <span class="n">kmax</span><span class="p">):</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span
            class="n">Uk</span><span class="p">,</span> <span class="n">lk</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">G</span><span
            class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">):</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span
            class="n">G</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span
            class="n">G</span><span class="o">.</span><span class="n">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span
            class="n">k</span><span class="o">=</span><span class="n">kmax</span><span class="p">,</span> <span
            class="n">which</span><span class="o">=</span><span class="s2">&quot;SM&quot;</span><span class="p">,</span> <span
            class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

    <span class="c1"># Avoid divide by zero issues</span>
    <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">1</span>
    <span class="n">linv</span> <span class="o">=</span> <span class="n">l</span> <span class="o">**</span> <span
            class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">linv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Compute coarsening-specific matrices</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Pi</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span
            class="n">T</span> <span class="o">@</span> <span class="n">C</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">get_S</span><span class="p">(</span><span
            class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Lc</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">dot</span><span
            class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">L</span><span
            class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span
            class="o">.</span><span class="n">T</span><span class="p">))</span>
    <span class="n">Lp</span> <span class="o">=</span> <span class="n">Pi</span> <span class="o">@</span> <span
            class="n">G</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Pi</span>

    <span class="c1"># Compute eigenvalues and eigenvectors of the coarsened Laplacian</span>
    <span class="k">if</span> <span class="n">kmax</span> <span class="o">&gt;</span> <span class="n">n</span> <span
            class="o">/</span> <span class="mi">2</span><span class="p">:</span>
        <span class="p">[</span><span class="n">Uc</span><span class="p">,</span> <span class="n">lc</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span
            class="n">Lc</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lc</span><span class="p">,</span> <span class="n">Uc</span> <span class="o">=</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span
            class="n">Lc</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">kmax</span><span
            class="p">,</span> <span class="n">which</span><span class="o">=</span><span
            class="s2">&quot;SM&quot;</span><span class="p">,</span> <span class="n">tol</span><span
            class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span
            class="n">Lc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span
            class="s2">&quot;warning: Lc should be sparse.&quot;</span><span class="p">)</span>

    <span class="n">metrics</span> <span class="o">=</span> <span class="p">{</span><span
            class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="mi">1</span> <span
            class="o">-</span> <span class="n">n</span> <span class="o">/</span> <span class="n">N</span><span
            class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="nb">int</span><span
            class="p">((</span><span class="n">Lc</span><span class="o">.</span><span class="n">nnz</span> <span
            class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span
            class="mi">2</span><span class="p">)}</span>

    <span class="n">kmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">clip</span><span class="p">(</span><span class="n">kmax</span><span class="p">,</span> <span
            class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="c1"># Eigenvalue relative error</span>
    <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_eigenvalue&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">[:</span><span
            class="n">kmax</span><span class="p">]</span> <span class="o">-</span> <span class="n">lc</span><span
            class="p">[:</span><span class="n">kmax</span><span class="p">])</span> <span class="o">/</span> <span
            class="n">l</span><span class="p">[:</span><span class="n">kmax</span><span class="p">]</span>
    <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_eigenvalue&quot;</span><span
            class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span
            class="mi">0</span>

    <span class="c1"># Angles between eigenspaces</span>
    <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;angle_matrix&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span> <span
            class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span
            class="n">Uc</span>

    <span class="c1"># Initialize error arrays</span>
    <span class="n">kmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">clip</span><span class="p">(</span><span class="n">kmax</span><span class="p">,</span> <span
            class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">error_subspace</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kmax</span><span
            class="p">)</span>
    <span class="n">error_sintheta</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kmax</span><span
            class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">S</span> <span class="o">@</span> <span class="n">Pi</span> <span
            class="o">@</span> <span class="n">U</span> <span class="o">@</span> <span class="n">np</span><span
            class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">linv</span><span
            class="p">)</span>

    <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kmax</span><span
            class="p">):</span>
        <span class="n">error_subspace</span><span class="p">[</span><span class="n">kIdx</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span
            class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span
            class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M</span><span
            class="p">[:,</span> <span class="p">:</span> <span class="n">kIdx</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">],</span> <span class="nb">ord</span><span class="o">=</span><span
            class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span
            class="p">)</span>
        <span class="n">error_sintheta</span><span class="p">[</span><span class="n">kIdx</span><span class="p">]</span> <span
            class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span
            class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">metrics</span><span
            class="p">[</span><span class="s2">&quot;angle_matrix&quot;</span><span class="p">][</span><span class="mi">0</span><span
            class="p">:</span> <span class="n">kIdx</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">,</span> <span class="n">kIdx</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">:],</span> <span class="nb">ord</span><span class="o">=</span><span
            class="s2">&quot;fro&quot;</span><span class="p">)</span> <span class="o">**</span> <span
            class="mi">2</span>
        <span class="p">)</span>

    <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_subspace&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">error_subspace</span>
    <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_sintheta&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">error_sintheta</span>

    <span class="k">return</span> <span class="n">metrics</span></div>


<span class="c1"># def plot_coarsening(</span>
<span class="c1">#         Gall, Call, size=3, edge_width=0.8, node_size=20, alpha=0.55, title=&quot;&quot;</span>
<span class="c1"># ):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Plot a (hierarchical) coarsening</span>
<span class="c1">#</span>
<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     G_all : list of pygsp Graphs</span>
<span class="c1">#     Call  : list of np.arrays</span>
<span class="c1">#</span>
<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     fig : matplotlib figure</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # colors signify the size of a coarsened subgraph (&#39;k&#39; is 1, &#39;g&#39; is 2, &#39;b&#39; is 3, and so on)</span>
<span class="c1">#     colors = [&quot;k&quot;, &quot;g&quot;, &quot;b&quot;, &quot;r&quot;, &quot;y&quot;]</span>
<span class="c1">#</span>
<span class="c1">#     n_levels = len(Gall) - 1</span>
<span class="c1">#     if n_levels == 0:</span>
<span class="c1">#         return None</span>
<span class="c1">#     fig = plt.figure(figsize=(n_levels * size * 3, size * 2))</span>
<span class="c1">#</span>
<span class="c1">#     for level in range(n_levels):</span>
<span class="c1">#</span>
<span class="c1">#         G = Gall[level]</span>
<span class="c1">#         edges = np.array(G.get_edge_list()[0:2])</span>
<span class="c1">#</span>
<span class="c1">#         Gc = Gall[level + 1]</span>
<span class="c1">#         #         Lc = C.dot(G.L.dot(C.T))</span>
<span class="c1">#         #         Wc = sp.sparse.diags(Lc.diagonal(), 0) - Lc;</span>
<span class="c1">#         #         Wc = (Wc + Wc.T) / 2</span>
<span class="c1">#         #         Gc = gsp.graphs.Graph(Wc, coords=(C.power(2)).dot(G.coords))</span>
<span class="c1">#         edges_c = np.array(Gc.get_edge_list()[0:2])</span>
<span class="c1">#         C = Call[level]</span>
<span class="c1">#         C = C.toarray()</span>
<span class="c1">#</span>
<span class="c1">#         if G.coords.shape[1] == 2:</span>
<span class="c1">#             ax = fig.add_subplot(1, n_levels + 1, level + 1)</span>
<span class="c1">#             ax.axis(&quot;off&quot;)</span>
<span class="c1">#             ax.set_title(f&quot;{title} | level = {level}, N = {G.N}&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             [x, y] = G.coords.T</span>
<span class="c1">#             for eIdx in range(0, edges.shape[1]):</span>
<span class="c1">#                 ax.plot(</span>
<span class="c1">#                     x[edges[:, eIdx]],</span>
<span class="c1">#                     y[edges[:, eIdx]],</span>
<span class="c1">#                     color=&quot;k&quot;,</span>
<span class="c1">#                     alpha=alpha,</span>
<span class="c1">#                     lineWidth=edge_width,</span>
<span class="c1">#                 )</span>
<span class="c1">#             for i in range(Gc.N):</span>
<span class="c1">#                 subgraph = np.arange(G.N)[C[i, :] &gt; 0]</span>
<span class="c1">#                 ax.scatter(</span>
<span class="c1">#                     x[subgraph],</span>
<span class="c1">#                     y[subgraph],</span>
<span class="c1">#                     c=colors[np.clip(len(subgraph) - 1, 0, 4)],</span>
<span class="c1">#                     s=node_size * len(subgraph),</span>
<span class="c1">#                     alpha=alpha,</span>
<span class="c1">#                 )</span>
<span class="c1">#</span>
<span class="c1">#         elif G.coords.shape[1] == 3:</span>
<span class="c1">#             ax = fig.add_subplot(1, n_levels + 1, level + 1, projection=&quot;3d&quot;)</span>
<span class="c1">#             ax.axis(&quot;off&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             [x, y, z] = G.coords.T</span>
<span class="c1">#             for eIdx in range(0, edges.shape[1]):</span>
<span class="c1">#                 ax.plot(</span>
<span class="c1">#                     x[edges[:, eIdx]],</span>
<span class="c1">#                     y[edges[:, eIdx]],</span>
<span class="c1">#                     zs=z[edges[:, eIdx]],</span>
<span class="c1">#                     color=&quot;k&quot;,</span>
<span class="c1">#                     alpha=alpha,</span>
<span class="c1">#                     lineWidth=edge_width,</span>
<span class="c1">#                 )</span>
<span class="c1">#             for i in range(Gc.N):</span>
<span class="c1">#                 subgraph = np.arange(G.N)[C[i, :] &gt; 0]</span>
<span class="c1">#                 ax.scatter(</span>
<span class="c1">#                     x[subgraph],</span>
<span class="c1">#                     y[subgraph],</span>
<span class="c1">#                     z[subgraph],</span>
<span class="c1">#                     c=colors[np.clip(len(subgraph) - 1, 0, 4)],</span>
<span class="c1">#                     s=node_size * len(subgraph),</span>
<span class="c1">#                     alpha=alpha,</span>
<span class="c1">#                 )</span>
<span class="c1">#</span>
<span class="c1">#     # the final graph</span>
<span class="c1">#     Gc = Gall[-1]</span>
<span class="c1">#     edges_c = np.array(Gc.get_edge_list()[0:2])</span>
<span class="c1">#</span>
<span class="c1">#     if G.coords.shape[1] == 2:</span>
<span class="c1">#         ax = fig.add_subplot(1, n_levels + 1, n_levels + 1)</span>
<span class="c1">#         ax.axis(&quot;off&quot;)</span>
<span class="c1">#         [x, y] = Gc.coords.T</span>
<span class="c1">#         ax.scatter(x, y, c=&quot;k&quot;, s=node_size, alpha=alpha)</span>
<span class="c1">#         for eIdx in range(0, edges_c.shape[1]):</span>
<span class="c1">#             ax.plot(</span>
<span class="c1">#                 x[edges_c[:, eIdx]],</span>
<span class="c1">#                 y[edges_c[:, eIdx]],</span>
<span class="c1">#                 color=&quot;k&quot;,</span>
<span class="c1">#                 alpha=alpha,</span>
<span class="c1">#                 lineWidth=edge_width,</span>
<span class="c1">#             )</span>
<span class="c1">#</span>
<span class="c1">#     elif G.coords.shape[1] == 3:</span>
<span class="c1">#         ax = fig.add_subplot(1, n_levels + 1, n_levels + 1, projection=&quot;3d&quot;)</span>
<span class="c1">#         ax.axis(&quot;off&quot;)</span>
<span class="c1">#         [x, y, z] = Gc.coords.T</span>
<span class="c1">#         ax.scatter(x, y, z, c=&quot;k&quot;, s=node_size, alpha=alpha)</span>
<span class="c1">#         for eIdx in range(0, edges_c.shape[1]):</span>
<span class="c1">#             ax.plot(</span>
<span class="c1">#                 x[edges_c[:, eIdx]],</span>
<span class="c1">#                 y[edges_c[:, eIdx]],</span>
<span class="c1">#                 z[edges_c[:, eIdx]],</span>
<span class="c1">#                 color=&quot;k&quot;,</span>
<span class="c1">#                 alpha=alpha,</span>
<span class="c1">#                 lineWidth=edge_width,</span>
<span class="c1">#             )</span>
<span class="c1">#</span>
<span class="c1">#     ax.set_title(f&quot;{title} | level = {n_levels}, n = {Gc.N}&quot;)</span>
<span class="c1">#     fig.tight_layout()</span>
<span class="c1">#     return fig</span>


<span class="c1">################################################################################</span>
<span class="c1"># Variation-based contraction algorithms</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="contract_variation_edges"><a class="viewcode-back"
                                                             href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.contract_variation_edges">[docs]</a><span
        class="k">def</span> <span class="nf">contract_variation_edges</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span
        class="kc">None</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">10</span><span
        class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.5</span><span
        class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span
        class="s2">&quot;greedy&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform sequential contraction with local variation and edge-based families.</span>

<span class="sd">    This is a specialized implementation for the edge-based family, optimized for</span>
<span class="sd">    faster performance compared to the general `contract_variation()` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graphs.Graph</span>
<span class="sd">        The original graph to be coarsened.</span>
<span class="sd">    A : np.array, optional</span>
<span class="sd">        A matrix used in the subgraph cost function. Default is None.</span>
<span class="sd">    K : int, optional</span>
<span class="sd">        The number of clusters or partitions. Default is 10.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        The reduction ratio. Default is 0.5.</span>
<span class="sd">    algorithm : str, optional</span>
<span class="sd">        The algorithm used for edge contraction. Can be &quot;greedy&quot; or &quot;optimal&quot;. Default is &quot;greedy&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coarsening_list : list</span>
<span class="sd">        A list of edges to be contracted based on the selected algorithm.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is designed for edge-based families and works slightly faster than</span>
<span class="sd">    the `contract_variation()` function, which is more general.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pygsp import graphs</span>
<span class="sd">    &gt;&gt;&gt; G = graphs.Sensor(20)</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.rand(20, 20)</span>
<span class="sd">    &gt;&gt;&gt; coarsening_list = contract_variation_edges(G, A, K=5, r=0.3, algorithm=&quot;greedy&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">M</span> <span
            class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">N</span><span
            class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">dw</span><span class="p">,</span> <span
            class="n">G</span><span class="o">.</span><span class="n">Ne</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Pibot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span
            class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span
            class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">ones</span><span
            class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">subgraph_cost</span><span class="p">(</span><span
            class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">edge</span><span
            class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the cost of contracting a subgraph defined by an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : pygsp.graphs.Graph</span>
<span class="sd">            The original graph.</span>
<span class="sd">        A : np.array</span>
<span class="sd">            A matrix used in the cost calculation.</span>
<span class="sd">        edge : np.array</span>
<span class="sd">            An edge defined by its two nodes and its weight.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The cost of contracting the subgraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span
            class="n">edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span
            class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">int_</span><span class="p">),</span> <span class="n">edge</span><span
            class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">deg_new</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span
            class="n">deg</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span
            class="o">-</span> <span class="n">w</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">([[</span><span class="n">deg_new</span><span class="p">[</span><span
            class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">w</span><span
            class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span
            class="n">deg_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">Pibot</span> <span class="o">@</span> <span
            class="n">A</span><span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span
            class="p">:]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span
            class="n">B</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">L</span> <span
            class="o">@</span> <span class="n">B</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subgraph_cost_old</span><span class="p">(</span><span class="n">G</span><span
            class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">edge</span><span
            class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the cost of contracting a subgraph using an older method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : pygsp.graphs.Graph</span>
<span class="sd">            The original graph.</span>
<span class="sd">        A : np.array</span>
<span class="sd">            A matrix used in the cost calculation.</span>
<span class="sd">        edge : np.array</span>
<span class="sd">            An edge defined by its two nodes and its weight.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The cost of contracting the subgraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span
            class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span
            class="mi">1</span><span class="p">]]</span>
        <span class="n">deg_new</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span
            class="n">deg</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span
            class="o">-</span> <span class="n">w</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">([[</span><span class="n">deg_new</span><span class="p">[</span><span
            class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">w</span><span
            class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span
            class="n">deg_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">Pibot</span> <span class="o">@</span> <span
            class="n">A</span><span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span
            class="p">:]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span
            class="n">B</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">L</span> <span
            class="o">@</span> <span class="n">B</span><span class="p">)</span>

    <span class="c1"># Get the edge list from the graph</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">())</span>
    <span class="c1"># Calculate the weights for each edge based on the subgraph cost function</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">([</span><span class="n">subgraph_cost</span><span
            class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">A</span><span
            class="p">,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span
            class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)])</span>

    <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;optimal&quot;</span><span
            class="p">:</span>
        <span class="c1"># Identify the minimum weight matching</span>
        <span class="n">coarsening_list</span> <span class="o">=</span> <span class="n">matching_optimal</span><span
            class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span><span
            class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">r</span><span
            class="o">=</span><span class="n">r</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;greedy&quot;</span><span
            class="p">:</span>
        <span class="c1"># Find a heavy weight matching</span>
        <span class="n">coarsening_list</span> <span class="o">=</span> <span class="n">matching_greedy</span><span
            class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weights</span><span
            class="o">=-</span><span class="n">weights</span><span class="p">,</span> <span class="n">r</span><span
            class="o">=</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coarsening_list</span></div>


<div class="viewcode-block" id="contract_variation_linear"><a class="viewcode-back"
                                                              href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.contract_variation_linear">[docs]</a><span
        class="k">def</span> <span class="nf">contract_variation_linear</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span
        class="kc">None</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">10</span><span
        class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.5</span><span
        class="p">,</span> <span class="n">mode</span><span class="o">=</span><span
        class="s2">&quot;neighborhood&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform sequential contraction with local variation and general families.</span>

<span class="sd">    This implementation improves running speed at the expense of being more</span>
<span class="sd">    greedy, potentially resulting in slightly larger errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graphs.Graph</span>
<span class="sd">        The original graph to be coarsened.</span>
<span class="sd">    A : np.array, optional</span>
<span class="sd">        A matrix used in the subgraph cost function. If None, it will be computed. Default is None.</span>
<span class="sd">    K : int, optional</span>
<span class="sd">        The number of clusters or partitions. Default is 10.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        The reduction ratio. Default is 0.5.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        The mode of contraction. Can be &quot;neighborhood&quot;, &quot;cliques&quot;, &quot;edges&quot;, or &quot;triangles&quot;. Default is &quot;neighborhood&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coarsening_list : list</span>
<span class="sd">        A list of node sets to be contracted based on the selected mode.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is designed for general families and aims to speed up the process</span>
<span class="sd">    by being more greedy, potentially at the cost of higher error.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pygsp import graphs</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; G = graphs.Sensor(20)</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.rand(20, 10)</span>
<span class="sd">    &gt;&gt;&gt; coarsening_list = contract_variation_linear(G, A, K=5, r=0.3, mode=&quot;neighborhood&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">W_lil</span> <span
            class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">N</span><span
            class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">dw</span><span class="p">,</span> <span
            class="n">G</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">tolil</span><span
            class="p">()</span>

    <span class="c1"># Compute A if not provided</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span
            class="p">:</span>
        <span class="n">lk</span><span class="p">,</span> <span class="n">Uk</span> <span class="o">=</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span
            class="n">k</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">which</span><span
            class="o">=</span><span class="s2">&quot;SM&quot;</span><span class="p">,</span> <span
            class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
        <span class="n">lk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">1</span>
        <span class="n">lsinv</span> <span class="o">=</span> <span class="n">lk</span> <span class="o">**</span> <span
            class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">lsinv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">0</span>
        <span class="n">lk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">Uk</span> <span class="o">@</span> <span
            class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span
            class="n">lsinv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subgraph_cost</span><span class="p">(</span><span class="n">nodes</span><span
            class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the cost of contracting a subgraph defined by nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : array-like</span>
<span class="sd">            An array of node indices defining the subgraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The cost of contracting the subgraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">nodes</span><span class="p">)</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">ones</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W_lil</span><span class="p">[</span><span
            class="n">nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span
            class="n">nodes</span><span class="p">]</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">diag</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span
            class="n">deg</span><span class="p">[</span><span class="n">nodes</span><span class="p">]</span> <span
            class="o">-</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span
            class="p">(</span><span class="n">ones</span><span class="p">))</span> <span class="o">-</span> <span
            class="n">W</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nc</span><span
            class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span
            class="n">outer</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span
            class="n">ones</span><span class="p">)</span> <span class="o">/</span> <span class="n">nc</span><span
            class="p">)</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">nodes</span><span
            class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span
            class="n">B</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">L</span> <span
            class="o">@</span> <span class="n">B</span><span class="p">)</span> <span class="o">/</span> <span
            class="p">(</span><span class="n">nc</span> <span class="o">-</span> <span class="mi">1</span><span
            class="p">)</span>

    <span class="k">class</span> <span class="nc">CandidateSet</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class representing a candidate set of nodes for contraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span
            class="bp">self</span><span class="p">,</span> <span class="n">candidate_list</span><span
            class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span
            class="o">=</span> <span class="n">candidate_list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span
            class="o">=</span> <span class="n">subgraph_cost</span><span class="p">(</span><span class="n">candidate_list</span><span
            class="p">)</span>

        <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span
            class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">cost</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span
            class="n">cost</span>

    <span class="n">family</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">W_bool</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">A</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span
            class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span
            class="p">,</span> <span class="nb">format</span><span class="o">=</span><span
            class="s2">&quot;csr&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;neighborhood&quot;</span> <span class="ow">in</span> <span
            class="n">mode</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">i_set</span> <span class="o">=</span> <span class="n">W_bool</span><span
            class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span
            class="n">indices</span>
            <span class="n">family</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">CandidateSet</span><span class="p">(</span><span
            class="n">i_set</span><span class="p">))</span>

    <span class="k">if</span> <span class="s2">&quot;cliques&quot;</span> <span class="ow">in</span> <span class="n">mode</span><span
            class="p">:</span>
        <span class="n">Gnx</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span
            class="n">from_scipy_sparse_array</span><span class="p">(</span><span class="n">G</span><span
            class="o">.</span><span class="n">W</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">clique</span> <span class="ow">in</span> <span
            class="n">nx</span><span class="o">.</span><span class="n">find_cliques</span><span class="p">(</span><span
            class="n">Gnx</span><span class="p">):</span>
            <span class="n">family</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">CandidateSet</span><span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clique</span><span
            class="p">)))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;edges&quot;</span> <span class="ow">in</span> <span class="n">mode</span><span
            class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()[</span><span class="mi">0</span><span
            class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">family</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">CandidateSet</span><span class="p">(</span><span
            class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]))</span>
        <span class="k">if</span> <span class="s2">&quot;triangles&quot;</span> <span class="ow">in</span> <span
            class="n">mode</span><span class="p">:</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="nb">set</span><span
            class="p">()</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()[</span><span class="mi">0</span><span
            class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">N</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span
            class="n">w</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span
            class="ow">and</span> <span class="n">G</span><span class="o">.</span><span class="n">W</span><span
            class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span
            class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">triangles</span><span class="o">.</span><span class="n">add</span><span
            class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">u</span><span
            class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]))</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="nb">list</span><span
            class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span
            class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span
            class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span
            class="p">)),</span> <span class="n">triangles</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">triangles</span><span
            class="p">:</span>
                <span class="n">family</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">CandidateSet</span><span class="p">(</span><span class="n">triangle</span><span
            class="p">))</span>

    <span class="n">family</span> <span class="o">=</span> <span class="n">SortedList</span><span
            class="p">(</span><span class="n">family</span><span class="p">)</span>
    <span class="n">marked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span
            class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="n">coarsening_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">floor</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span
            class="n">N</span><span class="p">)</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">family</span><span
            class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i_cset</span> <span class="o">=</span> <span class="n">family</span><span
            class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span
            class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">i_set</span> <span class="o">=</span> <span class="n">i_cset</span><span class="o">.</span><span
            class="n">set</span>

        <span class="n">i_marked</span> <span class="o">=</span> <span class="n">marked</span><span
            class="p">[</span><span class="n">i_set</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span
            class="n">i_marked</span><span class="p">):</span>
            <span class="n">n_gain</span> <span class="o">=</span> <span class="nb">len</span><span
            class="p">(</span><span class="n">i_set</span><span class="p">)</span> <span class="o">-</span> <span
            class="mi">1</span>
            <span class="k">if</span> <span class="n">n_gain</span> <span class="o">&gt;</span> <span
            class="n">n_reduce</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">marked</span><span class="p">[</span><span class="n">i_set</span><span
            class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">coarsening_list</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">i_set</span><span class="p">)</span>
            <span class="n">n_reduce</span> <span class="o">-=</span> <span class="n">n_gain</span>

            <span class="k">if</span> <span class="n">n_reduce</span> <span class="o">&lt;=</span> <span
            class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_set</span> <span class="o">=</span> <span class="n">i_set</span><span
            class="p">[</span><span class="o">~</span><span class="n">i_marked</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">i_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span
            class="p">:</span>
                <span class="n">i_cset</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span
            class="n">i_set</span>
                <span class="n">i_cset</span><span class="o">.</span><span class="n">cost</span> <span
            class="o">=</span> <span class="n">subgraph_cost</span><span class="p">(</span><span
            class="n">i_set</span><span class="p">)</span>
                <span class="n">family</span><span class="o">.</span><span class="n">add</span><span
            class="p">(</span><span class="n">i_cset</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coarsening_list</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># Edge-based contraction algorithms</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="get_proximity_measure"><a class="viewcode-back"
                                                          href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.get_proximity_measure">[docs]</a><span
        class="k">def</span> <span class="nf">get_proximity_measure</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span
        class="n">K</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a proximity measure for edges in the graph based on various heuristics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graphs.Graph</span>
<span class="sd">        The input graph.</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the proximity measure to be calculated. Options include &quot;heavy_edge&quot;, &quot;algebraic_JC&quot;,</span>
<span class="sd">        &quot;affinity_GS&quot;, &quot;heavy_edge_degree&quot;, &quot;min_expected_loss&quot;, &quot;min_expected_gradient_loss&quot;, &quot;rss&quot;, &quot;rss_lanczos&quot;,</span>
<span class="sd">        &quot;rss_cheby&quot;, &quot;algebraic_GS&quot;.</span>
<span class="sd">    K : int, optional</span>
<span class="sd">        The number of clusters or partitions. Default is 10.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    proximity : np.array</span>
<span class="sd">        An array containing the proximity measure for each edge in the graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pygsp import graphs</span>
<span class="sd">    &gt;&gt;&gt; G = graphs.Sensor(20)</span>
<span class="sd">    &gt;&gt;&gt; proximity = get_proximity_measure(G, &quot;heavy_edge&quot;, K=5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">N</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span>  <span class="c1"># Adjacency matrix of the graph</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">dw</span>  <span
            class="c1"># Degree of each node</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()[</span><span class="mi">0</span><span
            class="p">:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># Edge list</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>  <span
            class="c1"># Weights of edges</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span
            class="c1"># Number of edges</span>

    <span class="n">num_vectors</span> <span class="o">=</span> <span class="n">K</span>  <span class="c1"># Number of vectors for test vectors generation</span>
    <span class="k">if</span> <span class="s2">&quot;lanczos&quot;</span> <span class="ow">in</span> <span class="n">name</span><span
            class="p">:</span>
        <span class="n">l_lan</span><span class="p">,</span> <span class="n">X_lan</span> <span class="o">=</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span
            class="n">k</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">which</span><span
            class="o">=</span><span class="s2">&quot;SM&quot;</span><span class="p">,</span> <span
            class="n">tol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;cheby&quot;</span> <span class="ow">in</span> <span class="n">name</span><span
            class="p">:</span>
        <span class="n">X_cheby</span> <span class="o">=</span> <span class="n">generate_test_vectors</span><span
            class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">num_vectors</span><span
            class="o">=</span><span class="n">num_vectors</span><span class="p">,</span> <span
            class="n">method</span><span class="o">=</span><span class="s2">&quot;Chebychev&quot;</span><span class="p">,</span> <span
            class="n">lambda_cut</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span
            class="n">e</span><span class="p">[</span><span class="n">K</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;JC&quot;</span> <span class="ow">in</span> <span
            class="n">name</span><span class="p">:</span>
        <span class="n">X_jc</span> <span class="o">=</span> <span class="n">generate_test_vectors</span><span
            class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">num_vectors</span><span
            class="o">=</span><span class="n">num_vectors</span><span class="p">,</span> <span
            class="n">method</span><span class="o">=</span><span class="s2">&quot;JC&quot;</span><span
            class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">20</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;GS&quot;</span> <span class="ow">in</span> <span
            class="n">name</span><span class="p">:</span>
        <span class="n">X_gs</span> <span class="o">=</span> <span class="n">generate_test_vectors</span><span
            class="p">(</span>
            <span class="n">G</span><span class="p">,</span> <span class="n">num_vectors</span><span
            class="o">=</span><span class="n">num_vectors</span><span class="p">,</span> <span
            class="n">method</span><span class="o">=</span><span class="s2">&quot;GS&quot;</span><span
            class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;expected&quot;</span> <span class="ow">in</span> <span class="n">name</span><span
            class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X_lan</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span
            class="n">isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span
            class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span
            class="n">N</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">proximity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span
            class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span
            class="n">float32</span><span class="p">)</span>

    <span class="c1"># heuristic for multigrid</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;heavy_edge&quot;</span><span
            class="p">:</span>
        <span class="n">wmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span
            class="n">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">W</span><span
            class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span
            class="p">())[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span
            class="mf">1e-5</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span
            class="n">e</span><span class="p">]</span> <span class="o">/</span> <span class="nb">max</span><span
            class="p">(</span>
                <span class="n">wmax</span><span class="p">[</span><span class="n">edges</span><span
            class="p">[:,</span> <span class="n">e</span><span class="p">]]</span>
            <span class="p">)</span>  <span class="c1"># Select edges with large proximity</span>
        <span class="k">return</span> <span class="n">proximity</span>

    <span class="c1"># heuristic for multigrid</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;algebraic_JC&quot;</span><span
            class="p">:</span>
        <span class="n">proximity</span> <span class="o">+=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">Inf</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">num_vectors</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">X_jc</span><span class="p">[:,</span> <span
            class="n">kIdx</span><span class="p">]</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span
            class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span
            class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span
            class="p">(</span><span class="n">xk</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span class="p">[</span><span
            class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span
            class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># Select edges with large proximity</span>
        <span class="k">return</span> <span class="n">proximity</span>

    <span class="c1"># heuristic for multigrid</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;affinity_GS&quot;</span><span
            class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span
            class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_gs</span><span
            class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span
            class="o">@</span> <span class="n">X_gs</span><span class="p">[</span><span class="n">j</span><span
            class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span
            class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">X_gs</span><span class="p">[</span><span
            class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span
            class="n">X_gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span
            class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">**</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">X_gs</span><span
            class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span
            class="o">@</span> <span class="n">X_gs</span><span class="p">[</span><span class="n">j</span><span
            class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span
            class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>  <span class="c1"># Select edges with large proximity</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span
            class="n">T</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span
            class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
            <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span
            class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span
            class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">c</span><span
            class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span> <span
            class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span
            class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="k">return</span> <span class="n">proximity</span>

    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span
            class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;heavy_edge_degree&quot;</span><span
            class="p">:</span>
            <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span
            class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">deg</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span> <span class="o">+</span> <span class="n">deg</span><span class="p">[</span><span
            class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span
            class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">W</span><span
            class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">]</span>
            <span class="p">)</span>  <span class="c1"># Select edges with large proximity</span>

        <span class="c1"># Custom: minimize expected loss</span>
        <span class="k">elif</span> <span class="s2">&quot;min_expected_loss&quot;</span> <span
            class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span
            class="n">K</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">X</span><span
            class="p">[:,</span> <span class="n">kIdx</span><span class="p">]</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">proximity</span><span class="p">[</span><span
            class="n">e</span><span class="p">],</span> <span class="p">(</span><span class="n">xk</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span
            class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span
            class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># Select edges with small proximity</span>

        <span class="c1"># Custom: minimize expected gradient loss</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;min_expected_gradient_loss&quot;</span><span
            class="p">:</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span
            class="n">K</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">X</span><span
            class="p">[:,</span> <span class="n">kIdx</span><span class="p">]</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">],</span>
                        <span class="p">(</span><span class="n">xk</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span
            class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">deg</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">deg</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">]),</span>
                    <span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># Select edges with small proximity</span>

        <span class="c1"># Custom: relaxation ensuring alignment of K first eigenspaces</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;rss&quot;</span><span
            class="p">:</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span
            class="n">K</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">U</span><span class="p">[:,</span> <span class="n">kIdx</span><span class="p">]</span>
                <span class="n">lk</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">e</span><span class="p">[</span><span class="n">kIdx</span><span class="p">]</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">],</span>
                        <span class="p">(</span><span class="n">xk</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span
            class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span
            class="mi">2</span>
                        <span class="o">*</span> <span class="p">((</span><span class="n">deg</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">deg</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">4</span><span
            class="p">)</span>
                        <span class="o">/</span> <span class="n">lk</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># Select edges with small proximity</span>

        <span class="c1"># Custom: fast relaxation ensuring alignment of K first eigenspaces</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;rss_lanczos&quot;</span><span
            class="p">:</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span
            class="n">K</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">X_lan</span><span
            class="p">[:,</span> <span class="n">kIdx</span><span class="p">]</span>
                <span class="n">lk</span> <span class="o">=</span> <span class="n">l_lan</span><span
            class="p">[</span><span class="n">kIdx</span><span class="p">]</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">],</span>
                        <span class="p">(</span><span class="n">xk</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span
            class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span
            class="mi">2</span>
                        <span class="o">*</span> <span class="p">((</span><span class="n">deg</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">deg</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">4</span> <span
            class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span
            class="n">lk</span> <span class="o">+</span> <span class="n">lk</span><span class="p">))</span>
                        <span class="o">/</span> <span class="n">lk</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># Select edges with small proximity</span>

        <span class="c1"># Custom: approximate relaxation ensuring alignment of K first eigenspaces</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;rss_cheby&quot;</span><span
            class="p">:</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">num_vectors</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">X_cheby</span><span
            class="p">[:,</span> <span class="n">kIdx</span><span class="p">]</span>
                <span class="n">lk</span> <span class="o">=</span> <span class="n">xk</span><span
            class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">G</span><span class="o">.</span><span
            class="n">L</span> <span class="o">@</span> <span class="n">xk</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">],</span>
                        <span class="p">(</span>
                                <span class="p">(</span><span class="n">xk</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span
            class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span
            class="mi">2</span>
                                <span class="o">*</span> <span class="p">((</span><span class="n">deg</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">deg</span><span
            class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span
            class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span
            class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">4</span> <span
            class="o">-</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">lk</span><span
            class="p">)</span>
                                <span class="o">/</span> <span class="n">lk</span>
                        <span class="p">),</span>
                    <span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># Select edges with small proximity</span>

        <span class="c1"># Heuristic for multigrid (algebraic multigrid)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;algebraic_GS&quot;</span><span
            class="p">:</span>
            <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">Inf</span>
            <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">num_vectors</span><span class="p">):</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">X_gs</span><span class="p">[:,</span> <span
            class="n">kIdx</span><span class="p">]</span>
                <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                    <span class="n">proximity</span><span class="p">[</span><span class="n">e</span><span
            class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">max</span><span
            class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span
            class="p">(</span><span class="n">xk</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span> <span class="o">-</span> <span class="n">xk</span><span class="p">[</span><span
            class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span
            class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># Select edges with large proximity</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;rss&quot;</span> <span class="ow">in</span> <span
            class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span
            class="s2">&quot;expected&quot;</span> <span class="ow">in</span> <span class="n">name</span><span
            class="p">):</span>
        <span class="n">proximity</span> <span class="o">=</span> <span class="o">-</span><span
            class="n">proximity</span>

    <span class="k">return</span> <span class="n">proximity</span></div>



<div class="viewcode-block" id="generate_test_vectors"><a class="viewcode-back"
                                                          href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.generate_test_vectors">[docs]</a><span
        class="k">def</span> <span class="nf">generate_test_vectors</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">num_vectors</span><span class="o">=</span><span
            class="mi">10</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span
            class="s2">&quot;Gauss-Seidel&quot;</span><span class="p">,</span> <span class="n">iterations</span><span
            class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">lambda_cut</span><span
            class="o">=</span><span class="mf">0.1</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate test vectors for graph processing using different iterative methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graphs.Graph</span>
<span class="sd">        The input graph.</span>
<span class="sd">    num_vectors : int, optional</span>
<span class="sd">        The number of test vectors to generate. Default is 10.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        The iterative method to use for generating the test vectors. Options are &quot;Gauss-Seidel&quot;, &quot;Jacobi&quot;, and &quot;Chebychev&quot;.</span>
<span class="sd">        Default is &quot;Gauss-Seidel&quot;.</span>
<span class="sd">    iterations : int, optional</span>
<span class="sd">        The number of iterations to perform for the iterative methods. Default is 5.</span>
<span class="sd">    lambda_cut : float, optional</span>
<span class="sd">        The eigenvalue cutoff for the Chebychev method. Default is 0.1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        An array containing the generated test vectors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pygsp import graphs</span>
<span class="sd">    &gt;&gt;&gt; G = graphs.Sensor(20)</span>
<span class="sd">    &gt;&gt;&gt; X = generate_test_vectors(G, num_vectors=5, method=&quot;Jacobi&quot;, iterations=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">L</span>  <span class="c1"># Laplacian matrix of the graph</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">N</span>  <span class="c1"># Number of nodes in the graph</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span
            class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span
            class="p">,</span> <span class="n">num_vectors</span><span class="p">)</span> <span class="o">/</span> <span
            class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span
            class="n">N</span><span class="p">)</span>  <span class="c1"># Initial random test vectors</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span
            class="s2">&quot;GS&quot;</span> <span class="ow">or</span> <span class="n">method</span> <span
            class="o">==</span> <span class="s2">&quot;Gauss-Seidel&quot;</span><span class="p">:</span>
        <span class="c1"># Gauss-Seidel method</span>
        <span class="n">L_upper</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span
            class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span
            class="nb">format</span><span class="o">=</span><span class="s2">&quot;csc&quot;</span><span
            class="p">)</span>  <span class="c1"># Upper triangular part of L</span>
        <span class="n">L_lower_diag</span> <span class="o">=</span> <span class="n">sp</span><span
            class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">triu</span><span
            class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span
            class="nb">format</span><span class="o">=</span><span class="s2">&quot;csc&quot;</span><span
            class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Lower triangular part + diagonal of L</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">num_vectors</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span
            class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">iterations</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">sp</span><span
            class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span
            class="o">.</span><span class="n">spsolve_triangular</span><span class="p">(</span><span class="n">L_lower_diag</span><span
            class="p">,</span> <span class="n">L_upper</span> <span class="o">@</span> <span class="n">x</span><span
            class="p">)</span>
            <span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">X</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span
            class="s2">&quot;JC&quot;</span> <span class="ow">or</span> <span class="n">method</span> <span
            class="o">==</span> <span class="s2">&quot;Jacobi&quot;</span><span class="p">:</span>
        <span class="c1"># Jacobi method</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">dw</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>  <span
            class="c1"># Degrees of nodes</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span
            class="n">deg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span
            class="c1"># Diagonal matrix of degrees</span>
        <span class="n">deginv</span> <span class="o">=</span> <span class="n">deg</span> <span
            class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span
            class="p">)</span>  <span class="c1"># Inverse of degrees</span>
        <span class="n">deginv</span><span class="p">[</span><span class="n">deginv</span> <span
            class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span
            class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Handle infinite values</span>
        <span class="n">Dinv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span
            class="n">deginv</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span
            class="c1"># Diagonal matrix of inverse degrees</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">Dinv</span><span class="o">.</span><span
            class="n">dot</span><span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span
            class="n">L</span><span class="p">)</span>  <span class="c1"># Jacobi iteration matrix</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">num_vectors</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span
            class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">iterations</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span
            class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span> <span
            class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span
            class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">X</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Chebychev&quot;</span><span
            class="p">:</span>
        <span class="c1"># Chebychev method</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span
            class="n">Filter</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span
            class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span
            class="n">x</span> <span class="o">&lt;=</span> <span class="n">lambda_cut</span><span
            class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span><span
            class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">filter</span><span
            class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span
            class="o">=</span><span class="s2">&quot;chebyshev&quot;</span><span class="p">,</span> <span class="n">order</span><span
            class="o">=</span><span class="mi">50</span><span class="p">)</span></div>



<div class="viewcode-block" id="matching_optimal"><a class="viewcode-back"
                                                     href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.matching_optimal">[docs]</a><span
        class="k">def</span> <span class="nf">matching_optimal</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span
        class="n">r</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a matching optimally with the objective of minimizing the total</span>
<span class="sd">    weight of all edges in the matching.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp graph</span>
<span class="sd">        The input graph.</span>
<span class="sd">    weights : np.array(M)</span>
<span class="sd">        A weight for each edge.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        The desired dimensionality reduction (ratio = 1 - n/N). Default is 0.4.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matching : np.array</span>
<span class="sd">        An array of shape (k, 2) where each row represents a matched pair of nodes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * The complexity of this algorithm is O(N^3).</span>
<span class="sd">    * Depending on G, the algorithm might fail to return ratios &gt; 0.3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">N</span>  <span class="c1"># Number of nodes in the graph</span>

    <span class="c1"># Get the edge list and format it</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span
            class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span
            class="c1"># Number of edges</span>

    <span class="n">max_weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span
            class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span
            class="n">weights</span><span class="p">)</span>  <span class="c1"># Max weight for normalization</span>

    <span class="c1"># Prepare the input for the minimum weight matching problem</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">edgeIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span
            class="n">edgeIdx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span
            class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># Skip self-loops</span>
        <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span
            class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span
            class="n">max_weight</span> <span class="o">-</span> <span class="n">weights</span><span
            class="p">[</span><span class="n">edgeIdx</span><span class="p">]))</span>

    <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">weights</span><span
            class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>  <span class="c1"># Ensure all weights are non-negative</span>

    <span class="c1"># Solve the minimum weight matching problem</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">maxWeightMatching</span><span
            class="p">(</span><span class="n">edge_list</span><span class="p">))</span>

    <span class="c1"># Format the output</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span
            class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span
            class="nb">int</span><span class="p">)</span>
    <span class="n">matching</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span
            class="p">)</span>
    <span class="n">matching</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">tmp</span>

    <span class="c1"># Remove null edges and duplicates</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">where</span><span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span
            class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span
            class="p">]</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">matching</span><span
            class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">where</span><span class="p">(</span><span class="n">matching</span><span
            class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span
            class="n">matching</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])[</span><span
            class="mi">0</span><span class="p">]</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">matching</span><span
            class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">assert</span> <span class="n">matching</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">&gt;=</span> <span class="mi">1</span>  <span
            class="c1"># Ensure there&#39;s at least one match</span>

    <span class="c1"># If the returned matching is larger than requested, select the min weight subset of it</span>
    <span class="n">matched_weights</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">matching</span><span
            class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span
            class="p">])</span>
    <span class="k">for</span> <span class="n">mIdx</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">matching</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">matching</span><span class="p">[</span><span
            class="n">mIdx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">matching</span><span class="p">[</span><span
            class="n">mIdx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">eIdx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">e</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">t</span> <span
            class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span
            class="n">edges</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span
            class="n">T</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">==</span> <span
            class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span><span
            class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span
            class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="p">[</span><span
            class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span
            class="n">all</span><span class="p">())</span>
        <span class="p">]</span>
        <span class="n">matched_weights</span><span class="p">[</span><span class="n">mIdx</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span
            class="n">eIdx</span><span class="p">]</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span
            class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span
            class="n">ceil</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span
            class="n">N</span><span class="p">)),</span> <span class="n">matching</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">keep</span> <span class="o">&lt;</span> <span
            class="n">matching</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span
            class="mi">0</span><span class="p">]:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">argpartition</span><span class="p">(</span><span class="n">matched_weights</span><span
            class="p">,</span> <span class="n">keep</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span
            class="mi">0</span><span class="p">:</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">matching</span> <span class="o">=</span> <span class="n">matching</span><span class="p">[</span><span
            class="n">idx</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">matching</span></div>



<div class="viewcode-block" id="matching_greedy"><a class="viewcode-back"
                                                    href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.matching_greedy">[docs]</a><span
        class="k">def</span> <span class="nf">matching_greedy</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span
        class="n">r</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a matching greedily by selecting at each iteration the edge</span>
<span class="sd">    with the largest weight and then removing all adjacent edges from the</span>
<span class="sd">    candidate set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp graph</span>
<span class="sd">        The input graph.</span>
<span class="sd">    weights : np.array(M)</span>
<span class="sd">        A weight for each edge.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        The desired dimensionality reduction (r = 1 - n/N). Default is 0.4.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matching : np.array</span>
<span class="sd">        An array of shape (k, 2) where each row represents a matched pair of nodes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * The complexity of this algorithm is O(M).</span>
<span class="sd">    * Depending on G, the algorithm might fail to return ratios &gt; 0.3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">N</span>  <span class="c1"># Number of nodes in the graph</span>

    <span class="c1"># Get the edge list and format it</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()[</span><span class="mi">0</span><span
            class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span
            class="c1"># Number of edges</span>

    <span class="c1"># Sort edges by weights in descending order</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">weights</span><span
            class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span
            class="n">idx</span><span class="p">]</span>

    <span class="c1"># The candidate edge set</span>
    <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span
            class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># The matching edge set (this is a list of arrays)</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Which vertices have been selected</span>
    <span class="n">marked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span
            class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span
            class="n">bool_</span><span class="p">)</span>

    <span class="n">n</span><span class="p">,</span> <span class="n">n_target</span> <span class="o">=</span> <span
            class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span
            class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span
            class="n">N</span>  <span class="c1"># Initial and target number of nodes</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">candidate_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span
            class="mi">0</span><span class="p">:</span>

        <span class="c1"># Pop a candidate edge</span>
        <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">candidate_edges</span><span
            class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span
            class="p">)</span>

        <span class="c1"># Check if either vertex is already marked</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">marked</span><span
            class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]):</span>
            <span class="k">continue</span>

        <span class="c1"># Mark both vertices</span>
        <span class="n">marked</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span
            class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Add the edge to the matching</span>
        <span class="n">matching</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span
            class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>

        <span class="c1"># Termination condition</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span
            class="n">n_target</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span
            class="p">(</span><span class="n">matching</span><span class="p">)</span></div>



<span class="c1">##############################################################################</span>
<span class="c1"># Sparsification and Kron reduction</span>
<span class="c1"># Most of the code has been adapted from the PyGSP implementation.</span>
<span class="c1">##############################################################################</span>
<div class="viewcode-block" id="kron_coarsening"><a class="viewcode-back"
                                                    href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.kron_coarsening">[docs]</a><span
        class="k">def</span> <span class="nf">kron_coarsening</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span
        class="mf">0.5</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span
        class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Kronecker coarsening on a graph G.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graph</span>
<span class="sd">        The input graph.</span>
<span class="sd">    r : float, optional</span>
<span class="sd">        The coarsening ratio (r = 1 - n/N). Default is 0.5.</span>
<span class="sd">    m : int, optional</span>
<span class="sd">        The target number of edges for sparsification. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Gc : pygsp.graph</span>
<span class="sd">        The coarsened graph.</span>
<span class="sd">    Gs[0] : pygsp.graph</span>
<span class="sd">        The original graph.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the coarsening fails, the function returns (None, None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure the graph has coordinates; if not, generate random coordinates</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span
            class="n">G</span><span class="p">,</span> <span class="s2">&quot;coords&quot;</span><span
            class="p">):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">set_coordinates</span><span
            class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span
            class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">G</span><span
            class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span
            class="c1"># needed by kron</span>

    <span class="c1"># Determine the target number of nodes after coarsening</span>
    <span class="n">n_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">floor</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span
            class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span
            class="n">N</span><span class="p">)</span>
    <span class="c1"># Calculate the number of levels of coarsening needed</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">N</span> <span class="o">/</span> <span class="n">n_target</span><span
            class="p">)))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Perform multiresolution coarsening</span>
        <span class="n">Gs</span> <span class="o">=</span> <span class="n">my_graph_multiresolution</span><span
            class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">levels</span><span class="p">,</span>
            <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span>
            <span class="n">sparsify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">sparsify_eps</span><span class="o">=</span><span class="kc">None</span><span
            class="p">,</span>
            <span class="n">reduction_method</span><span class="o">=</span><span class="s2">&quot;kron&quot;</span><span
            class="p">,</span>
            <span class="n">reg_eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Gk</span> <span class="o">=</span> <span class="n">Gs</span><span class="p">[</span><span
            class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># If a target number of edges m is specified, perform sparsification</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span
            class="kc">None</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">Gk</span><span class="o">.</span><span
            class="n">Ne</span>  <span class="c1"># Number of edges in the coarsened graph</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="nb">min</span><span
            class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="n">np</span><span
            class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">G</span><span
            class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="mf">0.3</span><span
            class="p">)</span>  <span class="c1"># Sparsification parameter</span>
            <span class="n">Gc</span> <span class="o">=</span> <span class="n">graph_sparsify</span><span
            class="p">(</span><span class="n">Gk</span><span class="p">,</span> <span class="n">epsilon</span><span
            class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">10</span><span
            class="p">)</span>
            <span class="n">Gc</span><span class="o">.</span><span class="n">mr</span> <span class="o">=</span> <span
            class="n">Gk</span><span class="o">.</span><span class="n">mr</span>  <span class="c1"># Maintain multiresolution information</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Gc</span> <span class="o">=</span> <span class="n">Gk</span>

        <span class="k">return</span> <span class="n">Gc</span><span class="p">,</span> <span class="n">Gs</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># Return None if coarsening fails</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="kron_quality"><a class="viewcode-back"
                                                 href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.kron_quality">[docs]</a><span
        class="k">def</span> <span class="nf">kron_quality</span><span class="p">(</span><span class="n">G</span><span
        class="p">,</span> <span class="n">Gc</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span
        class="mi">30</span><span class="p">,</span> <span class="n">Uk</span><span class="o">=</span><span class="kc">None</span><span
        class="p">,</span> <span class="n">lk</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the quality of Kronecker coarsening.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graph</span>
<span class="sd">        The original graph.</span>
<span class="sd">    Gc : pygsp.graph</span>
<span class="sd">        The coarsened graph.</span>
<span class="sd">    kmax : int, optional</span>
<span class="sd">        The maximum number of eigenvalues/eigenvectors to consider. Default is 30.</span>
<span class="sd">    Uk : np.array, optional</span>
<span class="sd">        Precomputed eigenvectors of the original graph. Default is None.</span>
<span class="sd">    lk : np.array, optional</span>
<span class="sd">        Precomputed eigenvalues of the original graph. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metrics : dict</span>
<span class="sd">        A dictionary containing various quality metrics of the coarsening.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function may fail, indicated by metrics[&#39;failed&#39;] being True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span
            class="n">G</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Gc</span><span
            class="o">.</span><span class="n">N</span>
    <span class="n">keep_inds</span> <span class="o">=</span> <span class="n">Gc</span><span class="o">.</span><span
            class="n">mr</span><span class="p">[</span><span class="s2">&quot;idx&quot;</span><span class="p">]</span>

    <span class="c1"># Initialize metrics</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="p">{</span><span
            class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="mi">1</span> <span
            class="o">-</span> <span class="n">n</span> <span class="o">/</span> <span class="n">N</span><span
            class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="nb">int</span><span
            class="p">(</span><span class="n">Gc</span><span class="o">.</span><span class="n">W</span><span
            class="o">.</span><span class="n">nnz</span> <span class="o">/</span> <span class="mi">2</span><span
            class="p">),</span> <span class="s2">&quot;failed&quot;</span><span class="p">:</span> <span class="kc">False</span><span
            class="p">}</span>
    <span class="n">kmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">clip</span><span class="p">(</span><span class="n">kmax</span><span class="p">,</span> <span
            class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="c1"># Determine eigenvalues and eigenvectors</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Uk</span> <span class="ow">is</span> <span
            class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span
            class="p">(</span><span class="n">lk</span> <span class="ow">is</span> <span class="ow">not</span> <span
            class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span
            class="nb">len</span><span class="p">(</span><span class="n">lk</span><span class="p">)</span> <span
            class="o">&gt;=</span> <span class="n">kmax</span><span class="p">):</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span
            class="n">Uk</span><span class="p">,</span> <span class="n">lk</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">G</span><span
            class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">):</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span
            class="n">G</span><span class="o">.</span><span class="n">U</span><span class="p">,</span> <span
            class="n">G</span><span class="o">.</span><span class="n">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span
            class="n">k</span><span class="o">=</span><span class="n">kmax</span><span class="p">,</span> <span
            class="n">which</span><span class="o">=</span><span class="s2">&quot;SM&quot;</span><span class="p">,</span> <span
            class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

    <span class="c1"># Adjust the smallest eigenvalue to avoid division by zero</span>
    <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">1</span>
    <span class="n">linv</span> <span class="o">=</span> <span class="n">l</span> <span class="o">**</span> <span
            class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">linv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span
            class="o">=</span> <span class="mi">0</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span
            class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">keep_inds</span><span
            class="p">,</span> <span class="p">:]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">L</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Compute pseudoinverse of L + regularization</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span
            class="n">L</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span
            class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span
            class="n">N</span><span class="p">))</span>
        <span class="n">Cinv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Phi</span> <span
            class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span><span
            class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span
            class="n">C</span> <span class="o">@</span> <span class="n">Phi</span> <span class="o">@</span> <span
            class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Compute eigenvalues and eigenvectors of the coarsened graph</span>
        <span class="k">if</span> <span class="n">kmax</span> <span class="o">&gt;</span> <span class="n">n</span> <span
            class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="p">[</span><span class="n">Uc</span><span class="p">,</span> <span class="n">lc</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span
            class="n">Gc</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">toarray</span><span
            class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lc</span><span class="p">,</span> <span class="n">Uc</span> <span class="o">=</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span
            class="n">Gc</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">k</span><span
            class="o">=</span><span class="n">kmax</span><span class="p">,</span> <span class="n">which</span><span
            class="o">=</span><span class="s2">&quot;SM&quot;</span><span class="p">,</span> <span
            class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>

        <span class="c1"># Calculate eigenvalue relative error</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_eigenvalue&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">[:</span><span
            class="n">kmax</span><span class="p">]</span> <span class="o">-</span> <span class="n">lc</span><span
            class="p">[:</span><span class="n">kmax</span><span class="p">])</span> <span class="o">/</span> <span
            class="n">l</span><span class="p">[:</span><span class="n">kmax</span><span class="p">]</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_eigenvalue&quot;</span><span
            class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span
            class="mi">0</span>

        <span class="c1"># Initialize error metrics</span>
        <span class="n">error_subspace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="n">kmax</span><span class="p">)</span>
        <span class="n">error_sintheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="n">kmax</span><span class="p">)</span>

        <span class="c1"># Calculate subspace error</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">U</span> <span class="o">-</span> <span
            class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span
            class="n">sqrtm</span><span class="p">(</span><span class="n">Cinv</span> <span class="o">@</span> <span
            class="n">Gc</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dot</span><span
            class="p">(</span><span class="n">C</span><span class="p">))</span> <span class="o">@</span> <span
            class="n">U</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span
            class="n">diag</span><span class="p">(</span><span class="n">linv</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kIdx</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span
            class="n">kmax</span><span class="p">):</span>
            <span class="n">error_subspace</span><span class="p">[</span><span class="n">kIdx</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span
            class="n">M</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">kIdx</span> <span
            class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">ord</span><span
            class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span
            class="mi">1</span><span class="p">)</span>

        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_subspace&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">error_subspace</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;error_sintheta&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">error_sintheta</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s2">&quot;failed&quot;</span><span class="p">]</span> <span
            class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">metrics</span></div>


<div class="viewcode-block" id="kron_interpolate"><a class="viewcode-back"
                                                     href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.kron_interpolate">[docs]</a><span
        class="k">def</span> <span class="nf">kron_interpolate</span><span class="p">(</span><span
        class="n">G</span><span class="p">,</span> <span class="n">Gc</span><span class="p">,</span> <span
        class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates a signal from the coarse graph to the original graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graph</span>
<span class="sd">        The original graph.</span>
<span class="sd">    Gc : pygsp.graph</span>
<span class="sd">        The coarsened graph.</span>
<span class="sd">    x : np.array</span>
<span class="sd">        The signal defined on the coarse graph nodes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        The interpolated signal on the original graph nodes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function uses the interpolation method from the reduction module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span
            class="p">(</span><span class="n">reduction</span><span class="o">.</span><span class="n">interpolate</span><span
            class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span
            class="p">,</span> <span class="n">Gc</span><span class="o">.</span><span class="n">mr</span><span
            class="p">[</span><span class="s2">&quot;idx&quot;</span><span class="p">]))</span></div>


<div class="viewcode-block" id="my_graph_multiresolution"><a class="viewcode-back"
                                                             href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.my_graph_multiresolution">[docs]</a><span
        class="k">def</span> <span class="nf">my_graph_multiresolution</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">levels</span><span class="p">,</span>
        <span class="n">r</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">sparsify_eps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">downsampling_method</span><span class="o">=</span><span class="s2">&quot;largest_eigenvector&quot;</span><span
            class="p">,</span>
        <span class="n">reduction_method</span><span class="o">=</span><span class="s2">&quot;kron&quot;</span><span
            class="p">,</span>
        <span class="n">compute_full_eigen</span><span class="o">=</span><span class="kc">False</span><span
            class="p">,</span>
        <span class="n">reg_eps</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute a pyramid of graphs (by Kron reduction).</span>

<span class="sd">    &#39;my_graph_multiresolution(G, levels)&#39; computes a multiresolution of</span>
<span class="sd">    a graph by repeatedly downsampling and performing graph reduction. The</span>
<span class="sd">    default downsampling method is the largest eigenvector method based on</span>
<span class="sd">    the polarity of the components of the eigenvector associated with the</span>
<span class="sd">    largest graph Laplacian eigenvalue. The default graph reduction method</span>
<span class="sd">    is Kron reduction followed by a graph sparsification step.</span>
<span class="sd">    *param* is a structure of optional parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graph</span>
<span class="sd">        The graph to reduce.</span>
<span class="sd">    levels : int</span>
<span class="sd">        Number of levels of decomposition.</span>
<span class="sd">    r : float</span>
<span class="sd">        Dimensionality reduction ratio (default is 0.5).</span>
<span class="sd">    sparsify : bool</span>
<span class="sd">        Whether to perform a spectral sparsification step immediately after</span>
<span class="sd">        the graph reduction (default is True).</span>
<span class="sd">    sparsify_eps : float</span>
<span class="sd">        Parameter epsilon used in the spectral sparsification</span>
<span class="sd">        (default is min(10/sqrt(G.N), 0.3)).</span>
<span class="sd">    downsampling_method : string</span>
<span class="sd">        The graph downsampling method (default is &#39;largest_eigenvector&#39;).</span>
<span class="sd">    reduction_method : string</span>
<span class="sd">        The graph reduction method (default is &#39;kron&#39;).</span>
<span class="sd">    compute_full_eigen : bool</span>
<span class="sd">        Whether to compute the graph Laplacian eigenvalues and eigenvectors</span>
<span class="sd">        for every graph in the multiresolution sequence (default is False).</span>
<span class="sd">    reg_eps : float</span>
<span class="sd">        The regularized graph Laplacian is L + epsilon * I.</span>
<span class="sd">        A smaller epsilon may lead to better regularization, but will also</span>
<span class="sd">        require a higher order Chebyshev approximation (default is 0.005).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Gs : list</span>
<span class="sd">        A list of graph layers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pygsp import reduction</span>
<span class="sd">    &gt;&gt;&gt; levels = 5</span>
<span class="sd">    &gt;&gt;&gt; G = graphs.Sensor(N=512)</span>
<span class="sd">    &gt;&gt;&gt; G.compute_fourier_basis()</span>
<span class="sd">    &gt;&gt;&gt; Gs = my_graph_multiresolution(G, levels, sparsify=False)</span>
<span class="sd">    &gt;&gt;&gt; for idx in range(levels):</span>
<span class="sd">    ...     Gs[idx].plotting[&#39;plot_name&#39;] = &#39;Reduction level: {}&#39;.format(idx)</span>
<span class="sd">    ...     Gs[idx].plot()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">sparsify_eps</span> <span class="ow">is</span> <span
            class="kc">None</span><span class="p">:</span>
        <span class="n">sparsify_eps</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span
            class="mf">10.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span
            class="n">sqrt</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span
            class="n">N</span><span class="p">),</span> <span class="mf">0.3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compute_full_eigen</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">compute_fourier_basis</span><span
            class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">estimate_lmax</span><span class="p">()</span>

    <span class="n">Gs</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span
            class="p">]</span>
    <span class="n">Gs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span
            class="o">.</span><span class="n">mr</span> <span class="o">=</span> <span class="p">{</span><span
            class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">np</span><span
            class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">G</span><span
            class="o">.</span><span class="n">N</span><span class="p">),</span> <span
            class="s2">&quot;orig_idx&quot;</span><span class="p">:</span> <span class="n">np</span><span
            class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">G</span><span
            class="o">.</span><span class="n">N</span><span class="p">)}</span>

    <span class="n">n_target</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span
            class="n">G</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span
            class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">levels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">downsampling_method</span> <span class="o">==</span> <span class="s2">&quot;largest_eigenvector&quot;</span><span
            class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span
            class="n">Gs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span
            class="s2">&quot;U&quot;</span><span class="p">):</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">Gs</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">U</span><span class="p">[:,</span> <span
            class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span
            class="n">eigs</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">L</span><span
            class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span
            class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">V</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">sign</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span
            class="mi">0</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span
            class="nb">int</span><span class="p">(</span><span class="n">Gs</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">N</span> <span
            class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">n_target</span><span
            class="p">)</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">argsort</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">flip</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span
            class="mi">0</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[:</span><span
            class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span
            class="s2">&quot;Unknown graph downsampling method.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reduction_method</span> <span class="o">==</span> <span class="s2">&quot;kron&quot;</span><span
            class="p">:</span>
            <span class="n">Gs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span
            class="n">reduction</span><span class="o">.</span><span class="n">kron_reduction</span><span
            class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span
            class="n">ind</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span
            class="s2">&quot;Unknown graph reduction method.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sparsify</span> <span class="ow">and</span> <span
            class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">N</span> <span class="o">&gt;</span> <span
            class="mi">2</span><span class="p">:</span>
            <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduction</span><span
            class="o">.</span><span class="n">graph_sparsify</span><span class="p">(</span>
                <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span
            class="nb">max</span><span class="p">(</span><span class="n">sparsify_eps</span><span
            class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span
            class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Gs</span><span
            class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)),</span> <span
            class="mf">1.0</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span
            class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_directed</span><span
            class="p">():</span>
            <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">Gs</span><span
            class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">]</span><span class="o">.</span><span class="n">W</span> <span class="o">+</span> <span class="n">Gs</span><span
            class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">]</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span
            class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">graphs</span><span
            class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">W</span><span
            class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">Gs</span><span
            class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span
            class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compute_full_eigen</span><span class="p">:</span>
            <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span><span class="o">.</span><span
            class="n">compute_fourier_basis</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">estimate_lmax</span><span
            class="p">()</span>

        <span class="n">Gs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span
            class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mr</span> <span
            class="o">=</span> <span class="p">{</span><span class="s2">&quot;idx&quot;</span><span
            class="p">:</span> <span class="n">ind</span><span class="p">,</span> <span
            class="s2">&quot;orig_idx&quot;</span><span class="p">:</span> <span class="n">Gs</span><span
            class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span
            class="n">mr</span><span class="p">[</span><span class="s2">&quot;orig_idx&quot;</span><span
            class="p">][</span><span class="n">ind</span><span class="p">],</span> <span
            class="s2">&quot;level&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>

        <span class="n">L_reg</span> <span class="o">=</span> <span class="n">Gs</span><span class="p">[</span><span
            class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">L</span> <span
            class="o">+</span> <span class="n">reg_eps</span> <span class="o">*</span> <span class="n">sp</span><span
            class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span
            class="p">(</span><span class="n">Gs</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">Gs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span
            class="o">.</span><span class="n">mr</span><span class="p">[</span><span class="s2">&quot;K_reg&quot;</span><span
            class="p">]</span> <span class="o">=</span> <span class="n">reduction</span><span class="o">.</span><span
            class="n">kron_reduction</span><span class="p">(</span><span class="n">L_reg</span><span class="p">,</span> <span
            class="n">ind</span><span class="p">)</span>
        <span class="n">Gs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span
            class="o">.</span><span class="n">mr</span><span class="p">[</span><span
            class="s2">&quot;green_kernel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filters</span><span
            class="o">.</span><span class="n">Filter</span><span class="p">(</span><span class="n">Gs</span><span
            class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">lambda</span> <span
            class="n">x</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span
            class="p">(</span><span class="n">reg_eps</span> <span class="o">+</span> <span class="n">x</span><span
            class="p">))</span>

    <span class="k">return</span> <span class="n">Gs</span></div>


<div class="viewcode-block" id="graph_sparsify"><a class="viewcode-back"
                                                   href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.graph_sparsify">[docs]</a><span
        class="k">def</span> <span class="nf">graph_sparsify</span><span class="p">(</span><span class="n">M</span><span
        class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">maxiter</span><span
        class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sparsifies a graph by sampling edges based on their resistance distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : pygsp.graph or scipy.sparse matrix</span>
<span class="sd">        The graph or its Laplacian matrix to be sparsified.</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Sparsification parameter, should be in the range [1/sqrt(N), 1).</span>
<span class="sd">    maxiter : int</span>
<span class="sd">        Maximum number of iterations for the sparsification process.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Mnew : pygsp.graph or scipy.sparse matrix</span>
<span class="sd">        The sparsified graph or its Laplacian matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check if input is a pygsp graph and retrieve Laplacian matrix</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span
            class="p">,</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Graph</span><span
            class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">M</span><span class="o">.</span><span
            class="n">lap_type</span> <span class="o">==</span> <span class="s2">&quot;combinatorial&quot;</span><span
            class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span
            class="n">L</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">M</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span
            class="p">(</span><span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Ensure epsilon is within the required range</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mf">1.0</span> <span class="o">/</span> <span
            class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span
            class="n">N</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span> <span
            class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;GRAPH_SPARSIFY: Epsilon out of required range&quot;</span><span
            class="p">)</span>

    <span class="c1"># Compute resistance distances</span>
    <span class="n">resistance_distances</span> <span class="o">=</span> <span class="n">resistance_distance</span><span
            class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span
            class="p">()</span>

    <span class="c1"># Get the weight matrix</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span
            class="p">,</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Graph</span><span
            class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span
            class="n">W</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">diag</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span
            class="n">diagonal</span><span class="p">())</span> <span class="o">-</span> <span class="n">L</span><span
            class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">W</span><span class="p">[</span><span class="n">W</span> <span class="o">&lt;</span> <span
            class="mf">1e-10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Convert weight matrix to sparse format and eliminate zeros</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span
            class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">W</span><span
            class="p">)</span>
    <span class="n">W</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span
            class="n">W</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span
            class="mf">1e-10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">tocsc</span><span
            class="p">()</span>
    <span class="n">W</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

    <span class="n">start_nodes</span><span class="p">,</span> <span class="n">end_nodes</span><span class="p">,</span> <span
            class="n">weights</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span
            class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">tril</span><span class="p">(</span><span class="n">W</span><span class="p">))</span>

    <span class="c1"># Calculate the new weights based on resistance distances</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span
            class="n">weights</span><span class="p">)</span>
    <span class="n">Re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span
            class="p">(</span><span class="mi">0</span><span class="p">,</span> <span
            class="n">resistance_distances</span><span class="p">[</span><span class="n">start_nodes</span><span
            class="p">,</span> <span class="n">end_nodes</span><span class="p">])</span>
    <span class="n">Pe</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">*</span> <span
            class="n">Re</span> <span class="o">+</span> <span class="mf">1e-4</span>
    <span class="n">Pe</span> <span class="o">=</span> <span class="n">Pe</span> <span class="o">/</span> <span
            class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span
            class="n">Pe</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
        <span class="c1"># Determine the number of samples needed</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span
            class="mf">30.0</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span
            class="n">C0</span>
        <span class="n">q</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span
            class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span
            class="n">log</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span
            class="o">*</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">C</span> <span
            class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span
            class="n">epsilon</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Sample edges based on their probabilities</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">stats</span><span class="o">.</span><span class="n">rv_discrete</span><span
            class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span
            class="n">Pe</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span
            class="n">Pe</span><span class="p">))</span><span class="o">.</span><span class="n">rvs</span><span
            class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span
            class="n">q</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">spin_counts</span> <span class="o">=</span> <span class="n">sp</span><span
            class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">itemfreq</span><span
            class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">.</span><span
            class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">per_spin_weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span
            class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">Pe</span><span
            class="p">)</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span
            class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">)[</span><span
            class="mi">0</span><span class="p">])</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">spin_counts</span><span
            class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span
            class="n">spin_counts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">new_weights</span> <span class="o">=</span> <span class="n">counts</span> <span
            class="o">*</span> <span class="n">per_spin_weights</span>

        <span class="c1"># Construct the new sparser weight matrix</span>
        <span class="n">sparserW</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">new_weights</span><span class="p">,</span> <span
            class="p">(</span><span class="n">start_nodes</span><span class="p">,</span> <span
            class="n">end_nodes</span><span class="p">)),</span> <span class="n">shape</span><span
            class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span
            class="n">N</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">sparserW</span> <span class="o">=</span> <span class="n">sparserW</span> <span
            class="o">+</span> <span class="n">sparserW</span><span class="o">.</span><span class="n">T</span>
        <span class="n">sparserL</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span
            class="n">sparserW</span><span class="o">.</span><span class="n">diagonal</span><span
            class="p">(),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span
            class="n">sparserW</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span
            class="p">,</span> <span class="n">graphs</span><span class="o">.</span><span class="n">Graph</span><span
            class="p">):</span>
        <span class="n">sparserW</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span
            class="n">sparserL</span><span class="o">.</span><span class="n">diagonal</span><span
            class="p">(),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span
            class="n">sparserL</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">M</span><span class="o">.</span><span
            class="n">is_directed</span><span class="p">():</span>
            <span class="n">sparserW</span> <span class="o">=</span> <span class="p">(</span><span
            class="n">sparserW</span> <span class="o">+</span> <span class="n">sparserW</span><span
            class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span
            class="mf">2.0</span>

        <span class="n">Mnew</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span
            class="n">Graph</span><span class="p">(</span><span class="n">W</span><span class="o">=</span><span
            class="n">sparserW</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Mnew</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span
            class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span
            class="p">(</span><span class="n">sparserL</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Mnew</span></div>


<div class="viewcode-block" id="get_S"><a class="viewcode-back"
                                          href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.get_S">[docs]</a><span
        class="k">def</span> <span class="nf">get_S</span><span class="p">(</span><span class="n">G</span><span
        class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the N x E gradient matrix S.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : pygsp.graphs.Graph</span>
<span class="sd">        The input graph.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        The gradient matrix of shape (N, E), where N is the number of nodes</span>
<span class="sd">        and E is the number of edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the edge list and weights</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span
            class="n">get_edge_list</span><span class="p">()</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span
            class="mi">2</span><span class="p">])</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span
            class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Construct the N x |E| gradient matrix S</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span
            class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">N</span><span
            class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span
            class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span
            class="p">):</span>
        <span class="n">S</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span
            class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">],</span> <span
            class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span
            class="p">[</span><span class="n">e</span><span class="p">])</span>
        <span class="n">S</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span
            class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">],</span> <span
            class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span
            class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">weights</span><span
            class="p">[</span><span class="n">e</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="eig"><a class="viewcode-back"
                                        href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.eig">[docs]</a><span
        class="k">def</span> <span class="nf">eig</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span
        class="n">order</span><span class="o">=</span><span class="s1">&#39;ascend&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform eigenvalue decomposition on a symmetric matrix and sort the eigenvalues</span>
<span class="sd">    and eigenvectors in ascending or descending order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray</span>
<span class="sd">        A symmetric matrix.</span>
<span class="sd">    order : str, optional</span>
<span class="sd">        The order in which to sort the eigenvalues and eigenvectors. Can be &#39;ascend&#39; (default)</span>
<span class="sd">        for ascending order or &#39;descend&#39; for descending order.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        Matrix of eigenvectors, where each column is an eigenvector.</span>
<span class="sd">    l : np.ndarray</span>
<span class="sd">        Array of eigenvalues, sorted in the specified order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Eigenvalue decomposition</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span
            class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># Reordering indices</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">argsort</span><span
            class="p">()</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span
            class="s1">&#39;descend&#39;</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[::</span><span
            class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Reordering eigenvalues and eigenvectors</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span
            class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span
            class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">np</span><span
            class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">l</span><span
            class="p">)</span></div>



<div class="viewcode-block" id="zero_diag"><a class="viewcode-back"
                                              href="../../../source/graphslim.coarsening.html#graphslim.coarsening.utils.zero_diag">[docs]</a><span
        class="k">def</span> <span class="nf">zero_diag</span><span class="p">(</span><span class="n">A</span><span
        class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the diagonal elements of a matrix to zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : np.ndarray or scipy.sparse matrix</span>
<span class="sd">        The input matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : np.ndarray or scipy.sparse matrix</span>
<span class="sd">        The matrix with diagonal elements set to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>

    <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span
            class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">A</span><span
            class="p">):</span>
        <span class="c1"># For sparse matrices, create a diagonal matrix from the original diagonal</span>
        <span class="c1"># and subtract it from the original matrix</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">-</span> <span class="n">sp</span><span
            class="o">.</span><span class="n">sparse</span><span class="o">.</span><span
            class="n">dia_matrix</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span
            class="n">diagonal</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span
            class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span
            class="mi">0</span><span class="p">]),</span> <span class="n">shape</span><span class="o">=</span><span
            class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span
            class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span
            class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For dense matrices, extract the diagonal, create a diagonal matrix from it,</span>
        <span class="c1"># and subtract it from the original matrix</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span
            class="n">diagonal</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">-</span> <span class="n">np</span><span
            class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">D</span><span
            class="p">)</span></div>

<span class="c1">##############################################################################</span>
</pre>
                        </div>

                    </div>
                </div>
                <footer>

                    <hr/>

                    <div role="contentinfo">
                        <p>&#169; Copyright 2024, Melody Group.</p>
                    </div>

                    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
                    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
                    provided by <a href="https://readthedocs.org">Read the Docs</a>.


                </footer>
            </div>
        </div>
    </section>
</div>
<script>
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
    });
</script>

</body>
</html>